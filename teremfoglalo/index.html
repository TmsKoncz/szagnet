<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SZAG Teremfoglaló</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Stílusok */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #4f46e5; animation: spin 1s linear infinite; }
        .modal-overlay { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; z-index: 50; padding: 1rem; opacity: 0; transition: opacity 300ms ease-in-out; pointer-events: none; }
        .modal-overlay.active { opacity: 1; pointer-events: auto; }
        .modal-content { background-color: white; padding: 1.5rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); transform: scale(0.95); transition: transform 300ms ease-in-out; max-width: 500px; width: 100%; }
        .modal-overlay.active .modal-content { transform: scale(1); }
        .hidden { display: none !important; }
        #admin-action-overlay { position: absolute; inset: 0; background-color: rgba(255, 255, 255, 0.75); display: flex; justify-content: center; align-items: center; z-index: 20; }
        #admin-action-overlay.hidden { display: none; }
        #admin-action-overlay .spinner { width: 24px; height: 24px; }
        .view-loading::after { content: 'Adatok betöltése...'; display: block; text-align: center; padding: 2rem; color: #6b7280; font-style: italic; }
        .book-button-disabled { cursor: not-allowed; opacity: 0.5; }
        .recurring-indicator-icon { display: inline-block; width: 0.8em; height: 0.8em; margin-left: 3px; vertical-align: -0.1em; fill: currentColor; color: #ca8a04; /* yellow-600 */ }
        /* Header elrejtése */
        body.no-header #app-header { display: none; }
        body.no-header #main-content { margin-top: 0; padding-top: 0; }

        /* Teljes képernyős elrendezés */
        html, body { height: 100%; overflow: hidden; }
        body { display: flex; flex-direction: column; }
        #main-content { flex-grow: 1; overflow-y: auto; padding-bottom: 60px; /* Hely a láblécnek */ }
        footer { flex-shrink: 0; }

        /* Idősáv kártya stílusa (Terem nézet) */
        .room-view-card-list .timeslot-box {
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out, background-color 0.2s ease-in-out;
            position: relative;
            border-left-width: 4px; /* Vékony szegély */
            padding-left: 1rem; /* Kisebb behúzás */
            padding-right: 4.5rem; /* Hely a jobb oldali jelzőnek */
            padding-top: 0.75rem; /* p-3 */
            padding-bottom: 0.75rem;
            min-height: 4.5rem;
            display: flex;
            align-items: center;
        }
        .room-view-card-list .timeslot-box.active {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.4);
            border-left-color: #4338ca !important; /* indigo-700 */
            background-color: #e0e7ff; /* indigo-100 */
            z-index: 10;
            min-height: 5rem;
        }
        .room-view-card-list .timeslot-box.next-up {
            background-color: #f0f9ff; /* sky-50 */
            border-left-color: #7dd3fc; /* sky-300 */
        }

        /* Jobb oldali állapotjelzők (Terem nézet) */
        .room-view-card-list .status-indicator {
            position: absolute;
            right: 0.75rem; /* px-3 */
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.7rem; /* Extra kicsi */
            font-weight: bold;
            padding: 0.15rem 0.5rem;
            border-radius: 0.375rem; /* rounded-md */
            color: white;
            text-transform: uppercase;
        }
        .room-view-card-list .status-indicator.active { background-color: #16a34a; } /* green-600 */
        .room-view-card-list .status-indicator.next { background-color: #0ea5e9; } /* sky-500 */

        /* Típus jelző (foglaló mellett) */
        .booking-type-badge {
            font-size: 0.75rem; /* text-xs */
            font-weight: 600;
            padding: 0.1rem 0.4rem;
            border-radius: 0.25rem;
            background-color: #1f2937; /* gray-800 */
            color: white;
            margin-left: 0.5rem;
            vertical-align: middle;
        }
         /* Napi nézet kártya stílusok (Listás nézet) */
         .daily-summary-list li {
            padding-top: 0.5rem; /* py-2 */
            padding-bottom: 0.5rem;
         }
         .daily-summary-list li.active {
             background-color: #eef2ff; /* indigo-50 */
             font-weight: 600; /* font-semibold */
         }
         /* Heti nézet cella tartalom */
         .weekly-booking-details { cursor: pointer; }
         .weekly-booking-details:hover { background-color: rgba(239, 246, 255, 0.5); } /* blue-50/50 */
         /* Admin hirdetmény sáv */
         #announcement-bar {
             background-color: #fffbeb; /* yellow-50 */
             color: #ca8a04; /* yellow-600 */
             border: 1px solid #fef3c7; /* yellow-200 */
         }
         /* Heti nézet navigációs gomb ikon mérete */
         .week-nav-button svg {
             width: 1.25rem; /* w-5 */
             height: 1.25rem; /* h-5 */
         }
    </style>
</head>
<body class="bg-gray-100 font-sans">

    <header id="app-header" class="bg-indigo-600 text-white p-4 shadow-md sticky top-0 z-30">
        <div class="container mx-auto flex flex-wrap justify-between items-center gap-y-2">
            <div class="flex items-center space-x-3">
                 <img src="logo.png" alt="SZAG Logo" class="h-8 w-8 rounded-full" onerror="this.style.display='none'">
                 <h1 class="text-xl font-bold cursor-pointer" onclick="navigateTo('#/')">SZAG Teremfoglaló</h1>
            </div>
            <nav class="flex items-center space-x-2 sm:space-x-4">
                <div id="nav-links" class="flex items-center space-x-2 sm:space-x-4"></div>
                <div id="user-status" class="flex items-center space-x-2">
                    <span class="text-sm text-indigo-200">Betöltés...</span>
                </div>
            </nav>
        </div>
    </header>

    <div id="announcement-bar" class="hidden container mx-auto mt-2 p-3 text-center text-sm rounded shadow">
        <span id="announcement-message"></span>
    </div>

    <main id="main-content" class="container mx-auto mt-4 pb-16">
        <div id="loading-view" class="flex flex-col justify-center items-center h-64 text-xl text-gray-600">
            <div class="spinner mb-4"></div>
            <p>Alkalmazás betöltése...</p>
        </div>
        <div id="error-view" class="hidden p-4 text-center text-red-700 bg-red-100 rounded-lg"></div>
        <div id="weekly-view" class="hidden view-loading px-4"></div>
        <div id="daily-summary-view" class="hidden view-loading"></div>
        <div id="room-view" class="hidden view-loading"></div>
        <div id="admin-view" class="hidden view-loading px-4"></div>
    </main>

    <div id="login-popup" class="hidden fixed bottom-0 left-0 right-0 bg-gray-800 text-white p-4 shadow-lg z-50 flex justify-center items-center">
        <p id="login-popup-message" class="mr-4">Ehhez a művelethez bejelentkezés szükséges.</p>
        <button id="google-login-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded inline-flex items-center transition duration-150 ease-in-out">
            <svg class="fill-current w-4 h-4 mr-2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48"><path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"/><path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"/><path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"/><path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"/><path fill="none" d="M0 0h48v48H0z"/></svg>
            <span id="login-button-text">Bejelentkezés iskolai Google-fiókkal</span>
            <svg id="login-spinner" class="hidden animate-spin ml-2 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
        </button>
         <button id="login-popup-close" class="ml-4 text-gray-400 hover:text-white text-2xl leading-none" title="Bezárás">&times;</button>
    </div>

    <div id="booking-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="text-xl font-bold mb-4 text-indigo-700">Teremfoglalás</h3>
            <div class="space-y-3 mb-4 text-gray-700">
                <p><span class="font-semibold">Terem:</span> <span id="modal-room-name"></span></p>
                <p><span class="font-semibold">Nap:</span> <span id="modal-day"></span> (<span id="modal-date"></span>)</p>
                <p><span class="font-semibold">Idősáv:</span> <span id="modal-timeslot"></span></p>
            </div>
            <div id="modal-user-selector-div" class="hidden mb-4">
                 <label for="modal-user-selector" class="block text-sm font-medium text-gray-700 mb-1">Foglaló felhasználó:</label>
                 <select id="modal-user-selector" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"></select>
            </div>
            <div class="mb-4">
                <label for="bookingUser" class="block text-sm font-medium text-gray-700 mb-1">Foglaló neve / Foglalás célja:</label>
                <input type="text" id="bookingUser" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="Pl. Nagy Péter / 10.A Informatika óra">
            </div>
             <div class="mb-4">
                <label for="bookingComment" class="block text-sm font-medium text-gray-700 mb-1">Megjegyzés (opcionális):</label>
                <input type="text" id="bookingComment" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="Pl. Dolgozatírás">
            </div>
            <div id="modal-recurring-option" class="hidden mb-4">
                <label class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="modal-is-recurring" class="rounded border-gray-300 text-indigo-600 shadow-sm focus:ring-indigo-500">
                    <span class="text-sm text-gray-700">Rendszeres foglalás (minden héten)</span>
                </label>
                 <p class="text-xs text-gray-500 mt-1">A rendszeres foglalás minden héten ugyanerre a napra és idősávra érvényes.</p>
            </div>
            <div class="flex justify-end space-x-3">
                <button id="modal-cancel-button" class="px-4 py-2 bg-gray-300 text-gray-800 rounded-md hover:bg-gray-400 transition duration-150">Mégse</button>
                <button id="modal-confirm-button" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition duration-150 flex items-center">
                    <span id="modal-confirm-text">Foglalás Mentése</span>
                     <svg id="modal-spinner" class="hidden animate-spin ml-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                </button>
            </div>
        </div>
    </div>

    <div id="custom-dialog" class="modal-overlay">
        <div class="modal-content max-w-sm">
            <p id="custom-dialog-message" class="text-gray-700 mb-4 whitespace-pre-wrap"></p>
            <div id="custom-dialog-buttons" class="flex justify-end space-x-3"></div>
        </div>
    </div>

     <div id="booking-details-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                 <h3 class="text-xl font-bold text-indigo-700">Foglalás Részletei</h3>
                 <button id="booking-details-close" class="text-gray-500 hover:text-gray-700 text-2xl leading-none">&times;</button>
            </div>
            <div id="booking-details-content" class="space-y-2 text-gray-800"></div>
            <div id="booking-details-actions" class="flex justify-end mt-4 space-x-3">
                 </div>
        </div>
    </div>


    <footer class="text-center text-gray-500 text-sm py-4 mt-auto flex items-center justify-center space-x-2">
        <span>Powered by</span>
        <img src="logo.png" alt="Logo" class="h-5 w-5 inline-block" onerror="this.style.display='none'">
        <span>SZAG Teremfoglaló &copy; <span id="current-year"></span></span>
    </footer>

    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore-compat.js"></script>

    <script>
        // --- Firebase Konfiguráció ---
        // CSERÉLD LE EZEKET AZ ÉRTÉKEKET A SAJÁT FIREBASE PROJEKTED ADATAIRA!
        const firebaseConfig = {
  apiKey: "AIzaSyAs8pqCdCnyFDRivyUJJPh9nc0R1yNCAys",
  authDomain: "teremfoglalo-913e0.firebaseapp.com",
  projectId: "teremfoglalo-913e0",
  storageBucket: "teremfoglalo-913e0.firebasestorage.app",
  messagingSenderId: "705982282868",
  appId: "1:705982282868:web:183b3c35161ee0bffce521"
};

        // --- Globális Változók ---
        let firebaseApp;
        let firestore;
        let auth;
        let googleProvider;
        let currentUser = undefined; // undefined: még nem ellenőriztük, null: nincs bejelentkezve, object: bejelentkezve
        let rooms = [];
        let timeSlots = [];
        let bookings = []; // Tartalmazza az egyszeri és rendszeres foglalásokat is
        let allowedUsers = []; // Engedélyezett UID-vel rendelkező felhasználók
        let pendingUsers = []; // Meghívott, de még be nem jelentkezett email címek
        let cancellations = []; // Rendszeres foglalások lemondott esetei
        let announcement = "";
        let currentView = 'loading';
        let currentRoomId = null;
        let unsubscribePublicListeners = [];
        let unsubscribeAdminListeners = [];
        const STATIC_DAYS = ['Hétfő', 'Kedd', 'Szerda', 'Csütörtök', 'Péntek'];
        let currentMonday = getMonday(new Date()); // Az aktuális hétfő dátuma
        let initialPublicDataLoaded = false; // Jelzi, hogy a kezdeti publikus adatok betöltődtek-e
        let clockInterval = null; // Az óra frissítésének intervalja
        let dayCheckInterval = null; // A napváltás ellenőrzésének intervalja
        let authStatePromise = null; // Promise, ami feloldódik, ha az auth state először beállt

        // --- DOM Elemek Referenciái ---
        const loadingView = document.getElementById('loading-view');
        const errorView = document.getElementById('error-view');
        const weeklyViewDiv = document.getElementById('weekly-view');
        const dailySummaryViewDiv = document.getElementById('daily-summary-view');
        const roomViewDiv = document.getElementById('room-view');
        const adminViewDiv = document.getElementById('admin-view');
        const loginPopup = document.getElementById('login-popup');
        const googleLoginButton = document.getElementById('google-login-button');
        const loginButtonText = document.getElementById('login-button-text');
        const loginSpinner = document.getElementById('login-spinner');
        const loginPopupCloseButton = document.getElementById('login-popup-close');
        const loginPopupMessage = document.getElementById('login-popup-message');
        const userStatusDiv = document.getElementById('user-status');
        const navLinksDiv = document.getElementById('nav-links');
        const mainContent = document.getElementById('main-content');
        const announcementBar = document.getElementById('announcement-bar');
        const announcementMessageSpan = document.getElementById('announcement-message');
        const bookingModalElement = document.getElementById('booking-modal');
        const modalRoomName = document.getElementById('modal-room-name');
        const modalDay = document.getElementById('modal-day');
        const modalDate = document.getElementById('modal-date');
        const modalTimeslot = document.getElementById('modal-timeslot');
        const modalBookingUserInput = document.getElementById('bookingUser');
        const modalBookingCommentInput = document.getElementById('bookingComment');
        const modalRecurringOptionDiv = document.getElementById('modal-recurring-option');
        const modalIsRecurringCheckbox = document.getElementById('modal-is-recurring');
        const modalCancelButton = document.getElementById('modal-cancel-button');
        const modalConfirmButton = document.getElementById('modal-confirm-button');
        const modalConfirmText = document.getElementById('modal-confirm-text');
        const modalSpinner = document.getElementById('modal-spinner');
        const modalUserSelectorDiv = document.getElementById('modal-user-selector-div');
        const modalUserSelector = document.getElementById('modal-user-selector');
        const customDialog = document.getElementById('custom-dialog');
        const customDialogMessage = document.getElementById('custom-dialog-message');
        const customDialogButtons = document.getElementById('custom-dialog-buttons');
        const bookingDetailsModal = document.getElementById('booking-details-modal');
        const bookingDetailsContent = document.getElementById('booking-details-content');
        const bookingDetailsActions = document.getElementById('booking-details-actions');
        const bookingDetailsCloseButton = document.getElementById('booking-details-close');


        // --- Dátum Segédfüggvények ---
        // Visszaadja a hétfő dátumát a megadott dátum alapján
        function getMonday(d) { d = new Date(d); const day = d.getDay(); const diff = d.getDate() - day + (day === 0 ? -6 : 1); return new Date(d.setDate(diff)); }
        // Dátum formázása YYYY-MM-DD formátumba
        function formatDateYYYYMMDD(d) { const year = d.getFullYear(); const month = (d.getMonth() + 1).toString().padStart(2, '0'); const day = d.getDate().toString().padStart(2, '0'); return `${year}-${month}-${day}`; }
        // Dátum formázása rövid formátumba (pl. máj. 16.)
        function formatShortDate(d) { return d.toLocaleDateString('hu-HU', { month: 'short', day: 'numeric' }); }
        // Dátum formázása teljes formátumba (pl. 2025. május 16., péntek)
        function formatFullDate(d) { return d.toLocaleDateString('hu-HU', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' }); }
        // Idő formázása HH:MM:SS formátumba
        function formatTime(d) { return d.toLocaleTimeString('hu-HU', { hour: '2-digit', minute: '2-digit', second: '2-digit' }); }
        // Visszaadja a hét napjainak dátumait a hétfő dátumától kezdve
        function getWeekDates(mondayDate) { const dates = []; for (let i = 0; i < 5; i++) { const date = new Date(mondayDate); date.setDate(mondayDate.getDate() + i); dates.push(date); } return dates; }
        // Hét váltása (előre/hátra)
        function changeWeek(direction) { const newMonday = new Date(currentMonday); newMonday.setDate(currentMonday.getDate() + (direction * 7)); currentMonday = newMonday; console.log("Changing week to Monday:", formatDateYYYYMMDD(currentMonday)); if (currentView === 'weekly') { renderWeeklyView(); } }
        // Visszaadja az aktuális nap nevét (Hétfő, Kedd, ...)
        function getTodayDayName() { const days = ['Vasárnap', 'Hétfő', 'Kedd', 'Szerda', 'Csütörtök', 'Péntek', 'Szombat']; return days[new Date().getDay()]; }
        // Megkeresi az aktuális időpontnak megfelelő idősávot
        function getCurrentTimeSlot(timeSlots) {
             if (!timeSlots || timeSlots.length === 0) return null;
             const now = new Date();
             const hours = now.getHours();
             const minutes = now.getMinutes();
             const currentTime = hours * 60 + minutes; // Aktuális idő percekben
             const sortedSlots = [...timeSlots].sort((a, b) => (a.order ?? 0) - (b.order ?? 0));

             for (const slot of sortedSlots) {
                 if (!slot.value || !slot.value.includes(' - ')) continue;
                 try {
                     const [startTime, endTime] = slot.value.split(' - ');
                     const [startHour, startMinute] = startTime.split(':').map(Number);
                     const [endHour, endMinute] = endTime.split(':').map(Number);

                     if (isNaN(startHour) || isNaN(startMinute) || isNaN(endHour) || isNaN(endMinute)) continue;

                     const slotStart = startHour * 60 + startMinute;
                     const slotEnd = endHour * 60 + endMinute;

                     // Ellenőrizzük, hogy az aktuális idő a slot kezdete és vége között van-e (vége kizárva)
                     if (currentTime >= slotStart && currentTime < slotEnd) {
                         return slot.value;
                     }
                 } catch (e) {
                     console.error("Error parsing time slot:", slot.value, e);
                     continue;
                 }
             }
             return null;
        }
        // Megkeresi a következő idősávot
        function getNextTimeSlot(timeSlots) {
            if (!timeSlots || timeSlots.length === 0) return null;
            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            const currentTime = hours * 60 + minutes; // Aktuális idő percekben
            const sortedSlots = [...timeSlots].sort((a, b) => (a.order ?? 0) - (b.order ?? 0));

            for (const slot of sortedSlots) {
                if (!slot.value || !slot.value.includes(' - ')) continue;
                try {
                    const [startTime] = slot.value.split(' - ');
                    const [startHour, startMinute] = startTime.split(':').map(Number);

                    if (isNaN(startHour) || isNaN(startMinute)) continue;

                    const slotStart = startHour * 60 + startMinute;

                    // Ha a slot kezdete későbbi, mint az aktuális idő, ez a következő
                    if (slotStart > currentTime) {
                        return slot.value;
                    }
                } catch (e) {
                    console.error("Error parsing time slot for next:", slot.value, e);
                    continue;
                }
            }
            return null; // Nincs következő idősáv a mai napon
        }

        // Tisztítja a nevet (kisbetűs, ékezet nélkül, speciális karakterek nélkül)
        function sanitizeName(name) { if (!name) return ''; return name.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]/g, ''); }
        // Megkeresi a terem ID-t a tisztított név alapján
        function findRoomBySanitizedName(sanitizedName) { if (!sanitizedName) return null; const room = rooms.find(r => sanitizeName(r.name) === sanitizedName); return room ? room.id : null; }

        // --- Inicializálás ---
        function initializeApp() {
            console.log("initializeApp() called");
            try {
                if (!firebaseConfig || !firebaseConfig.apiKey || firebaseConfig.apiKey === "AIzaSyAs8pqCdCnyFDRivyUJJPh9nc0R1yNCAys") {
                     throw new Error("Firebase konfiguráció hiányzik vagy placeholder értékeket tartalmaz. Kérlek, frissítsd a firebaseConfig objektumot a saját projektadataiddal.");
                }
                firebaseApp = firebase.initializeApp(firebaseConfig);
                firestore = firebase.firestore();
                auth = firebase.auth();
                googleProvider = new firebase.auth.GoogleAuthProvider();
                console.log("Firebase (App, Firestore, Auth) sikeresen inicializálva.");
                setupEventListeners();
                setupPublicFirestoreListeners();
                setupAuthListener(); // Elindítja az auth state figyelését
                document.getElementById('current-year').textContent = new Date().getFullYear();
                startClockAndDayCheck(); // Elindítja az óra és napváltás figyelést
                console.log("initializeApp() finished successfully.");
            } catch (error) {
                console.error("Firebase inicializálási hiba:", error);
                showError(`Alkalmazás inicializálása sikertelen: ${error.message}.`);
            }
        }

        // --- Nézetváltás ---
        function switchView(viewId, roomId = null) {
            console.log(`Switching view to: ${viewId}`, roomId ? `with roomId: ${roomId}` : '');
            // Ne váltsunk nézetet, ha már abban vagyunk (kivéve loading)
            if (viewId === currentView && roomId === currentRoomId && viewId !== 'loading') {
                 console.log("Already in target view, skipping switch.");
                 // Ha admin nézetben vagyunk, de az admin adatok még töltődnek, próbáljuk újra renderelni
                 if (viewId === 'admin' && currentUser?.isAdmin && adminViewDiv.classList.contains('view-loading')) {
                     renderView();
                 }
                 return;
            }

            currentView = viewId;
            currentRoomId = roomId;

            // Header megjelenítése/elrejtése
            const shouldHideHeader = ['daily-summary', 'room'].includes(viewId);
            document.body.classList.toggle('no-header', shouldHideHeader);
            document.getElementById('app-header').classList.toggle('hidden', shouldHideHeader);
            mainContent.style.marginTop = shouldHideHeader ? '0' : ''; // Margin visszaállítása

            // Minden nézet elrejtése
            [loadingView, errorView, weeklyViewDiv, dailySummaryViewDiv, roomViewDiv, adminViewDiv]
                .forEach(el => el?.classList.add('hidden'));

            // Cél nézet megjelenítése
            const viewElement = document.getElementById(`${viewId}-view`);
            if (viewElement) {
                viewElement.classList.remove('hidden');
                // Ha az adatok már betöltődtek, rendereljük a nézetet, különben loading állapotot mutatunk
                if (initialPublicDataLoaded && !['loading', 'error'].includes(viewId)) {
                    console.log(`Rendering view: ${viewId}`);
                    renderView();
                } else if (['loading', 'error'].includes(viewId)) {
                     console.log(`Displaying special view: ${viewId}`);
                } else {
                     console.log(`View ${viewId} shown, waiting for initial data to render.`);
                     viewElement.classList.add('view-loading'); // Loading jelző hozzáadása
                }
            } else {
                console.error(`View element not found: ${viewId}-view`);
                showError(`A kért nézet (${viewId}) nem található.`);
            }
            updateNavLinks(); // Navigációs linkek frissítése
        }

        // --- Útvonal Kezelés ---
        async function handleRouteChange() {
            console.log(">>> handleRouteChange() called");
            const hash = window.location.hash || '#/';
            const url = new URL(window.location.href);
            const urlRoomNameParam = url.searchParams.get('id'); // Paraméter olvasása a search részből
            console.log("Current hash:", hash, "URL param 'id':", urlRoomNameParam);

            // Várjuk meg, amíg az auth state biztosan beállítódik, mielőtt jogosultság-függő routingot végzünk
            if (currentUser === undefined) {
                console.log("Routing skipped: Waiting for auth state...");
                if (authStatePromise) {
                    await authStatePromise;
                    console.log("Auth state promise resolved in handleRouteChange. Current user:", currentUser ? currentUser.uid : 'null');
                } else {
                    console.log("Routing skipped: Auth state promise not yet available.");
                    return; // Még nem indult el az auth listener
                }
            }

            // Ha még nem töltődtek be a publikus adatok, vagy hiba állapotban vagyunk, ne route-oljunk
            if (!initialPublicDataLoaded && currentView !== 'loading' || currentView === 'error') {
                 console.log("Routing skipped (initial public data not loaded or error state)");
                 // Ha loading nézetben vagyunk, de már betöltődtek az adatok, akkor is próbáljuk meg a routingot
                 if (initialPublicDataLoaded && currentView === 'loading') {
                      console.log("Initial public data loaded, re-attempting routing from loading state.");
                 } else {
                     return;
                 }
            }


            let targetView = '';
            let targetRoomId = null;

            // Terem nézet kezelése URL paraméter alapján
            if (urlRoomNameParam) {
                const foundRoomId = findRoomBySanitizedName(urlRoomNameParam);
                if (foundRoomId) {
                    console.log(`Room found by URL param: ${urlRoomNameParam} -> ${foundRoomId}`);
                    targetView = 'room';
                    targetRoomId = foundRoomId;
                     // Ha a hash nem #room, javítsuk ki, ez újraindítja a handleRouteChange-t
                     if (window.location.hash !== '#room') {
                        console.log("URL param found but hash is not #room, correcting hash.");
                        window.location.hash = '#room';
                        return; // hashchange event will re-trigger this
                    }
                } else {
                    console.error(`Room not found for URL param id: ${urlRoomNameParam}`);
                    showError(`A megadott terem (${urlRoomNameParam}) nem található.`);
                    // Ha hibás terem ID van az URL-ben, irányítsuk át a főoldalra
                    navigateTo('#/');
                    return;
                }
            }
            // Hash alapján történő routing
            else if (hash === '#/') targetView = 'weekly';
            else if (hash === '#/view') targetView = 'daily-summary';
            else if (hash.startsWith('#/room')) {
                 // Ha a hash #room, de nincs URL paraméter, irányítsuk a főoldalra
                 console.warn("Navigating to #room via hash without ?id= parameter is not supported. Redirecting to weekly.");
                 targetView = 'weekly';
                 navigateTo('#/');
                 return;
            } else if (hash === '#/admin') {
                // Admin nézet csak admin jogosultsággal
                if (currentUser?.isAdmin) { // Itt már biztosan tudjuk az admin státuszt az authStatePromise miatt
                    targetView = 'admin';
                    // Csak akkor indítjuk az admin listenereket, ha még nem futnak
                    if (unsubscribeAdminListeners.length === 0) {
                        setupAdminFirestoreListeners();
                    }
                } else {
                    console.warn("Admin access denied.");
                    if (!currentUser) { showLoginPopup("Az admin felület megtekintéséhez bejelentkezés szükséges."); }
                    else { showCustomAlert("Nincs jogosultságod az admin felület megtekintéséhez.", "Hiba"); }
                    // Irányítsuk át a főoldalra, ha nincs jogosultság
                    navigateTo('#/');
                    return; // Fontos, hogy itt kilépjünk, ne váltson nézetet
                }
            } else {
                // Ismeretlen hash esetén irányítsuk a főoldalra
                targetView = 'weekly';
                if (window.location.hash !== '#/') {
                    console.log("Unknown hash, navigating to #/");
                    navigateTo('#/');
                    return; // navigateTo újraindítja a handleRouteChange-t
                }
            }

            console.log("Routing: Target view determined:", targetView, "Target Room ID:", targetRoomId);
            // Váltás a cél nézetre
            switchView(targetView, targetRoomId);
        }

        // Navigálás adott hash-re (URL paraméter kezeléssel)
        function navigateTo(hash) {
            console.log("Navigating to:", hash);
            const currentUrl = new URL(window.location);
            const targetHash = hash.split('?')[0]; // Hash rész a paraméterek nélkül
            const targetParams = hash.split('?')[1] ? new URLSearchParams(hash.split('?')[1]) : new URLSearchParams();

            // Töröljük az 'id' paramétert, ha nem terem nézetre navigálunk
            if (targetHash !== '#room') {
                 currentUrl.searchParams.delete('id');
            }

            // Másoljuk át az új paramétereket (ha vannak)
            targetParams.forEach((value, key) => {
                 currentUrl.searchParams.set(key, value);
            });


            const newUrl = currentUrl.pathname + currentUrl.search + targetHash;
            const oldUrl = window.location.pathname + window.location.search + window.location.hash;

            // Csak akkor navigáljunk, ha az URL ténylegesen változik
            if (oldUrl !== newUrl) {
                 window.location.href = newUrl; // Ez vált hashchange eseményt
            } else {
                 // Ha az URL ugyanaz maradt, de a nézet más, akkor is kényszerítsük a nézet frissítést
                 const targetViewId = targetHash.substring(1) || 'weekly'; // '#/' -> 'weekly'
                 const targetRoomIdFromUrl = targetParams.get('id') ? findRoomBySanitizedName(targetParams.get('id')) : null;

                 if (currentView !== targetViewId || currentRoomId !== targetRoomIdFromUrl) {
                     console.log("URL is the same, but view/roomId differs. Forcing view switch.");
                     switchView(targetViewId, targetRoomIdFromUrl);
                 } else {
                     console.log("URL and view/roomId are the same, no action needed.");
                 }
            }
        }


        // --- Hiba Megjelenítés ---
        function showError(message) {
            console.error("Showing error:", message);
            errorView.textContent = `Hiba: ${message}`;
            // Minden más nézet elrejtése
            [loadingView, weeklyViewDiv, dailySummaryViewDiv, roomViewDiv, adminViewDiv]
                .forEach(el => el?.classList.add('hidden'));
            errorView.classList.remove('hidden'); // Hiba nézet megjelenítése
            currentView = 'error'; // Állapot frissítése
            initialPublicDataLoaded = true; // Hiba esetén is tekintsük betöltöttnek a kezdeti adatokat a routinghoz
            updateNavLinks(); // Navigációs linkek frissítése
        }

        // --- Felhasználói Felület Frissítése ---
        function updateUIBasedOnAuthState(user) {
             console.log("updateUIBasedOnAuthState called with user:", user ? user.uid : 'null');
            // Csak akkor frissítsük a UI-t, ha a felhasználó állapota ténylegesen megváltozott
            if (currentUser === user) {
                 console.log("User state unchanged, skipping UI update.");
                 return;
            }

            currentUser = user; // Fontos: currentUser beállítása itt

            if (user) { // Bejelentkezett felhasználó
                loginPopup.classList.add('hidden'); // Bejelentkezési popup elrejtése
                // Felhasználói státusz megjelenítése (név, admin státusz, kijelentkezés gomb)
                userStatusDiv.innerHTML = `
                    <span class="text-sm hidden lg:inline" title="${escapeHtml(user.email)}">${escapeHtml(user.nickname || user.displayName || user.email)} ${user.isAdmin ? '<span class="text-yellow-300">(Admin)</span>' : ''}</span>
                    <button id="logout-button" class="bg-red-500 hover:bg-red-600 text-white text-xs sm:text-sm font-semibold py-1 px-2 sm:px-3 rounded transition duration-150 ease-in-out">
                        Kijelentkezés
                    </button>
                `;
                // Kijelentkezés gomb eseményfigyelője
                const logoutBtn = document.getElementById('logout-button');
                if (logoutBtn) {
                    // Eltávolítjuk az esetleges korábbi figyelőt, hogy ne legyen duplán
                    logoutBtn.removeEventListener('click', handleLogout);
                    logoutBtn.addEventListener('click', handleLogout);
                }

                // Admin listenerek beállítása, ha a felhasználó admin és még nem futnak
                if (user.isAdmin && unsubscribeAdminListeners.length === 0) {
                    setupAdminFirestoreListeners();
                }

                 // Ha az auth state megváltozott ÉS a publikus adatok már betöltődtek, mindig újraértékeljük a routingot/nézetet
                 // Ez kezeli azt az esetet, ha valaki bejelentkezik/kijelentkezik, és az admin nézet elérhetővé/elérhetetlenné válik
                 if (initialPublicDataLoaded) {
                    console.log("Auth state changed and public data loaded, re-routing.");
                    handleRouteChange();
                 }

                 displayAnnouncement(); // Hirdetmény megjelenítése (csak bejelentkezett usernek)

            } else { // Nincs bejelentkezett felhasználó (kijelentkezett)
                 // Csak akkor frissítsük a UI-t, ha nem a kezdeti undefined állapotból lépünk null állapotba
                 // (az undefined -> null átmenetet a setupAuthListener kezeli)
                 if (currentUser !== undefined) {
                    // Bejelentkezés gomb megjelenítése
                    userStatusDiv.innerHTML = `<button id="show-login-button" class="bg-blue-500 hover:bg-blue-700 text-white text-sm font-semibold py-1 px-2 sm:px-3 rounded">Bejelentkezés</button>`;
                    const loginBtn = document.getElementById('show-login-button');
                    if (loginBtn) {
                        loginBtn.removeEventListener('click', () => showLoginPopup());
                        loginBtn.addEventListener('click', () => showLoginPopup());
                    }

                    // Admin listenerek leállítása, ha kijelentkezett
                    unsubscribeAdminFirestoreListeners();
                    allowedUsers = []; // Töröljük az admin adatokat
                    pendingUsers = [];
                    announcementBar.classList.add('hidden'); // Hirdetmény elrejtése

                    // Ha admin nézetben volt, irányítsuk át a főoldalra
                    if (currentView === 'admin') {
                        navigateTo('#/');
                    } else if (initialPublicDataLoaded && currentView !== 'loading' && currentView !== 'error') {
                        // Ha a publikus adatok betöltődtek, de nem admin vagy loading/error nézetben vagyunk,
                        // frissítsük az aktuális nézetet (pl. gombok letiltása)
                        renderView();
                    }
                 }
            }
             updateNavLinks(); // Navigációs linkek frissítése a jogosultság alapján
        }

        // Navigációs linkek frissítése (admin link megjelenítése/elrejtése)
        function updateNavLinks() {
            let linksHtml = `
                <button onclick="navigateTo('#/')" class="hover:bg-indigo-700 px-2 py-1 sm:px-3 rounded text-sm sm:text-base ${currentView === 'weekly' ? 'bg-indigo-800 font-semibold' : ''}">Heti nézet</button>
                <button onclick="navigateTo('#/view')" class="hover:bg-indigo-700 px-2 py-1 sm:px-3 rounded text-sm sm:text-base ${currentView === 'daily-summary' ? 'bg-indigo-800 font-semibold' : ''}">Napi összesítő</button>
            `;
            // Admin link hozzáadása, ha a felhasználó admin
            if (currentUser?.isAdmin) {
                linksHtml += `
                    <button onclick="navigateTo('#/admin')" class="hover:bg-purple-700 px-2 py-1 sm:px-3 rounded text-sm sm:text-base ${currentView === 'admin' ? 'bg-purple-800 font-semibold' : 'bg-purple-600'}">Admin</button>
                `;
            }
            navLinksDiv.innerHTML = linksHtml;
        }


        // --- Renderelő Függvények ---
        // Meghívja az aktuális nézetnek megfelelő renderelő függvényt
        function renderView() {
            console.log(`Attempting to render view: ${currentView}`);
            // Ne rendereljünk, ha a publikus adatok még nem töltődtek be (kivéve loading/error nézet)
            if (!initialPublicDataLoaded && currentView !== 'loading' && currentView !== 'error') {
                console.log("Render skipped: initial public data not loaded yet.");
                const viewElement = document.getElementById(`${currentView}-view`);
                viewElement?.classList.add('view-loading'); // Loading jelző megtartása
                return;
            }

            // Rejtjük a loading és error nézeteket, ha nem ezeket rendereljük
            if (!['loading', 'error'].includes(currentView)) {
                loadingView.classList.add('hidden');
                errorView.classList.add('hidden');
            } else {
                // Ha loading vagy error nézetben vagyunk, nincs további renderelés
                return;
            }

            const viewElement = document.getElementById(`${currentView}-view`);
            if (!viewElement) {
                 console.error(`Render failed: View element ${currentView}-view not found.`);
                 return;
            }
            // Loading jelző hozzáadása renderelés közben (ha még nincs rajta)
            if (!viewElement.classList.contains('view-loading')) {
                viewElement.classList.add('view-loading');
            }


            try {
                // Nézetnek megfelelő renderelő függvény hívása
                switch (currentView) {
                    case 'weekly': renderWeeklyView(); break;
                    case 'daily-summary': renderDailySummaryView(); break;
                    case 'room': renderRoomView(); break;
                    case 'admin':
                        // Admin nézet csak admin jogosultsággal
                        if (currentUser?.isAdmin) renderAdminView();
                        else navigateTo('#/'); // Ha mégis ide jutott nem admin, irányítsuk át
                        break;
                    default:
                        // Ismeretlen nézet esetén irányítsuk a főoldalra
                        navigateTo('#/');
                        return; // Kilépés a try-catch-ből
                }
                // Loading jelző eltávolítása sikeres renderelés után
                viewElement.classList.remove('view-loading');
            } catch (error) {
                // Hiba kezelése renderelés közben
                console.error(`Error rendering view ${currentView}:`, error);
                showError(`Hiba történt a(z) ${currentView} nézet megjelenítésekor: ${error.message}`);
                // Loading jelző eltávolítása hiba esetén is
                viewElement.classList.remove('view-loading');
            }
        }

        /** Heti nézet táblázatának generálása és megjelenítése */
        function renderWeeklyView() {
            console.log("Rendering Weekly View for date:", formatDateYYYYMMDD(currentMonday));
            weeklyViewDiv.innerHTML = ''; // Tartalom törlése

            const weekDates = getWeekDates(currentMonday); // A hét dátumai
            const weekDateStrings = weekDates.map(formatDateYYYYMMDD); // Dátumok YYYY-MM-DD formátumban
            const sortedTimeSlots = [...timeSlots].sort((a, b) => (a.order ?? 0) - (b.order ?? 0)); // Idősávok sorrendben
            const sortedRooms = [...rooms].sort((a, b) => a.name.localeCompare(b.name)); // Termek név szerint sorrendben

            // Szűrjük az egyszeri foglalásokat erre a hétre
            const singleBookingsThisWeek = bookings.filter(b => b.date && weekDateStrings.includes(b.date) && b.type === 'single');
            // Szűrjük a rendszeres foglalás sablonokat
            const recurringBookingTemplates = bookings.filter(b => b.type === 'recurring');
            // Szűrjük a lemondásokat erre a hétre
            const cancellationsThisWeek = cancellations.filter(c => weekDateStrings.includes(c.date));

            // Táblázat HTML generálása
            let tableHTML = `
                <div class="flex justify-between items-center mb-4">
                    <button onclick="changeWeek(-1)" class="week-nav-button bg-indigo-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.79 5.23a.75.75 0 01-.02 1.06L8.832 10l3.938 3.71a.75.75 0 11-1.04 1.08l-4.5-4.25a.75.75 0 010-1.08l4.5-4.25a.75.75 0 011.06.02z" clip-rule="evenodd" /></svg>
                    </button>
                    <h2 class="text-lg sm:text-xl font-bold text-center text-gray-800"> Heti Teremfoglalások <br class="sm:hidden"> (${formatShortDate(weekDates[0])} - ${formatShortDate(weekDates[4])})</h2>
                    <button onclick="changeWeek(1)" class="week-nav-button bg-indigo-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M7.21 14.77a.75.75 0 01.02-1.06L11.168 10 7.23 6.29a.75.75 0 111.04-1.08l4.5 4.25a.75.75 0 010 1.08l-4.5 4.25a.75.75 0 01-1.06-.02z" clip-rule="evenodd" /></svg>
                    </button>
                </div>
                <div class="overflow-x-auto shadow-md rounded-lg border border-gray-200">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-100">
                            <tr>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider sticky left-0 bg-gray-100 z-10 border-r">Idő / Nap</th>
                                ${weekDates.map((date, index) => `
                                    <th class="px-3 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider whitespace-nowrap border-l">
                                        ${STATIC_DAYS[index]}<br>(${formatShortDate(date)})
                                    </th>`).join('')}
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
                            ${sortedTimeSlots.map(slot => `
                                <tr class="divide-x divide-gray-100">
                                    <td class="px-3 py-4 whitespace-nowrap font-medium text-gray-900 sticky left-0 bg-white z-10 border-r">${escapeHtml(slot.value)}</td>
                                    ${weekDates.map((date, dayIndex) => {
                                        const dateString = weekDateStrings[dayIndex];
                                        const dayName = STATIC_DAYS[dayIndex];

                                        // Megkeressük az egyszeri foglalást erre a napra és idősávra
                                        let booking = singleBookingsThisWeek.find(b => b.roomId === room.id && b.date === dateString && b.timeSlot === slot.value);
                                        let isRecurringMatch = false; // Jelzi, ha rendszeres foglalás esete
                                        let isCancelled = false; // Jelzi, ha le van mondva az eset
                                        let recurringBookingId = null; // A rendszeres foglalás ID-je, ha van

                                        // Ha nincs egyszeri foglalás, ellenőrizzük a rendszeres foglalásokat
                                        if (!booking) {
                                            const recurringBooking = recurringBookingTemplates.find(b => b.roomId === room.id && b.day === dayName && b.timeSlot === slot.value);
                                            if (recurringBooking) {
                                                // Ellenőrizzük, hogy az adott napra le van-e mondva ez a rendszeres foglalás
                                                isCancelled = cancellationsThisWeek.some(c => c.recurringBookingId === recurringBooking.id && c.date === dateString);
                                                // Ha nincs lemondva, akkor ez egy érvényes rendszeres foglalás eset
                                                if (!isCancelled) {
                                                    booking = recurringBooking; // Használjuk a rendszeres sablont
                                                    isRecurringMatch = true;
                                                    recurringBookingId = booking.id; // Mentjük a rendszeres foglalás ID-jét
                                                }
                                            }
                                        }

                                        const isBooked = !!booking; // Van-e foglalás (egyszeri vagy rendszeres eset)
                                        // Ellenőrizzük, hogy a foglalás a jelenlegi felhasználóé-e (UID vagy pending email alapján)
                                        const isOwnBooking = isBooked && currentUser && (booking.userId === currentUser.uid || booking.userId === `pending:${currentUser.email?.toLowerCase()}`);

                                        // Gombok megjelenítésének/letiltásának logikája
                                        const canBook = !isBooked && !isCancelled && !!currentUser; // Foglalható, ha nincs foglalt, nincs lemondva és be van jelentkezve
                                        // Lemondható az egyszeri foglalás, ha a sajátod ÉS egyszeri
                                        const canDeleteSingle = isBooked && booking.type === 'single' && isOwnBooking;
                                        // Lemondható az adott napi rendszeres eset, ha a sajátod, rendszeres ÉS nincs lemondva
                                        const canCancelInstance = isBooked && booking.type === 'recurring' && isOwnBooking && !isCancelled;
                                        // Teljes rendszeres foglalás törölhető, ha admin vagy a sajátod ÉS rendszeres
                                        const canDeleteRecurring = isBooked && booking.type === 'recurring' && (currentUser?.isAdmin || isOwnBooking);


                                        const displayUser = booking?.user || '';
                                        const displayComment = booking?.comment || '';
                                        const fullText = displayUser + (displayComment ? ` (${displayComment})` : '');
                                        const displayName = fullText; // Megjelenítendő név a listában

                                        return `
                                            <td class="px-2 py-2 whitespace-nowrap text-sm text-gray-500 align-top">
                                                <ul class="space-y-1">
                                                    ${sortedRooms.map(room => {
                                                        // Itt meg kell keresni az adott teremre vonatkozó foglalást/lemondást
                                                        // Újra kell szűrni a bookings és cancellations tömböket az aktuális teremre
                                                        let roomBooking = singleBookingsThisWeek.find(b => b.roomId === room.id && b.date === dateString && b.timeSlot === slot.value);
                                                        let roomIsRecurringMatch = false;
                                                        let roomIsCancelled = false;
                                                        let roomRecurringBookingId = null;

                                                        if (!roomBooking) {
                                                            const roomRecurringBooking = recurringBookingTemplates.find(b => b.roomId === room.id && b.day === dayName && b.timeSlot === slot.value);
                                                            if (roomRecurringBooking) {
                                                                roomIsCancelled = cancellationsThisWeek.some(c => c.recurringBookingId === roomRecurringBooking.id && c.date === dateString);
                                                                if (!roomIsCancelled) {
                                                                    roomBooking = roomRecurringBooking;
                                                                    roomIsRecurringMatch = true;
                                                                    roomRecurringBookingId = roomBooking.id;
                                                                }
                                                            }
                                                        }

                                                        const roomIsBooked = !!roomBooking;
                                                        const roomIsOwnBooking = roomIsBooked && currentUser && (roomBooking.userId === currentUser.uid || roomBooking.userId === `pending:${currentUser.email?.toLowerCase()}`);

                                                        // Gombok jogosultság ellenőrzése az adott teremre
                                                        const roomCanBook = !roomIsBooked && !roomIsCancelled && !!currentUser;
                                                        const roomCanDeleteSingle = roomIsBooked && roomBooking.type === 'single' && roomIsOwnBooking;
                                                        const roomCanCancelInstance = roomIsBooked && roomBooking.type === 'recurring' && roomIsOwnBooking && !roomIsCancelled;
                                                        const roomCanDeleteRecurring = roomIsBooked && roomBooking.type === 'recurring' && (currentUser?.isAdmin || roomIsOwnBooking);
                                                        const roomCanDeleteAny = currentUser?.isAdmin && roomIsBooked; // Admin törölhet bármit

                                                        const roomDisplayUser = roomBooking?.user || '';
                                                        const roomDisplayComment = roomBooking?.comment || '';
                                                        const roomFullText = roomDisplayUser + (roomDisplayComment ? ` (${roomDisplayComment})` : '');
                                                        const roomDisplayName = roomFullText;

                                                        return `
                                                            <li class="flex items-center space-x-1.5 text-xs group relative">
                                                                <span class="inline-block w-2.5 h-2.5 rounded-full flex-shrink-0 ${roomIsBooked ? 'bg-red-500' : (roomIsCancelled ? 'bg-gray-400' : 'bg-green-500')}" title="${roomIsBooked ? 'Foglalt' : (roomIsCancelled ? 'Lemondva' : 'Szabad')}"></span>
                                                                <span class="flex-grow overflow-hidden overflow-ellipsis whitespace-nowrap ${roomIsBooked ? 'text-gray-700' : 'text-gray-500'} ${roomIsCancelled ? 'line-through text-gray-400' : ''} weekly-booking-details" ${roomIsBooked ? `onclick="showBookingDetails('${roomBooking.id}', ${roomIsRecurringMatch})"` : ''} title="${roomIsBooked ? escapeHtml(roomFullText) : (roomIsCancelled ? 'Lemondva' : '')}">
                                                                    ${escapeHtml(room.name)}
                                                                    ${roomIsBooked ? `<span class="${roomIsRecurringMatch ? 'text-yellow-700' : 'text-red-700'} font-medium"> (${roomDisplayName}${roomIsRecurringMatch ? `<svg class="recurring-indicator-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path fill-rule="evenodd" d="M13.836 2.477a.75.75 0 01.023 1.06l-4.25 4.5a.75.75 0 01-1.06.023L6.023 5.51a.75.75 0 011.06-1.06l2.19 2.19 3.726-3.936a.75.75 0 011.06-.023zM3.5 7.5a.75.75 0 01.75.75v2.5a.75.75 0 01-1.5 0v-2.5a.75.75 0 01.75-.75zM5.25 11a.75.75 0 000 1.5h5.5a.75.75 0 000-1.5h-5.5z" clip-rule="evenodd" /></svg>` : ''})</span>` : (roomIsCancelled ? '<span class="text-gray-500 italic">(Lemondva)</span>' : '')}
                                                                </span>
                                                                ${roomCanBook ? `
                                                                    <button
                                                                        onclick="handleBookingClick('${room.id}', '${escapeJsString(room.name)}', '${dayName}', '${escapeJsString(slot.value)}', '${dateString}')"
                                                                        class="ml-auto text-indigo-600 hover:text-indigo-900 text-[10px] font-semibold px-1 py-0.5 rounded hover:bg-indigo-50 opacity-0 group-hover:opacity-100 transition-opacity"
                                                                        title="Foglalás: ${escapeHtml(room.name)}, ${dayName} (${dateString}), ${escapeHtml(slot.value)}">
                                                                        Foglal
                                                                    </button>
                                                                ` : ''}
                                                                ${roomCanCancelInstance ? `
                                                                    <button
                                                                        onclick="cancelRecurringInstance('${roomBooking.id}', '${dateString}', '${escapeJsString(room.name)}', '${dayName} (${dateString})', '${escapeJsString(slot.value)}')"
                                                                        class="ml-1 text-orange-600 hover:text-orange-800 text-[10px] font-semibold px-1 py-0.5 rounded hover:bg-orange-50 opacity-0 group-hover:opacity-100 transition-opacity"
                                                                        title="Egyszeri lemondás erre a napra">
                                                                        Lemond
                                                                    </button>
                                                                ` : ''}
                                                                ${roomIsBooked && roomCanDeleteAny ? `
                                                                    <button
                                                                        onclick="deleteBooking('${roomBooking.id}', '${escapeJsString(room.name)}', '${dayName} (${dateString})', '${escapeJsString(slot.value)}', '${escapeJsString(roomBooking.user)}', ${roomIsRecurringMatch})"
                                                                        class="ml-1 text-red-500 hover:text-red-800 text-[10px] font-semibold px-1 py-0.5 rounded hover:bg-red-50 opacity-0 group-hover:opacity-100 transition-opacity"
                                                                        title="Foglalás Törlése ${roomIsRecurringMatch ? '(Teljes Rendszeres!)' : ''}">
                                                                        X
                                                                    </button>
                                                                ` : ''}
                                                            </li>
                                                        `;
                                                    }).join('')}
                                                </ul>
                                            </td>
                                        `;
                                    }).join('')}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            weeklyViewDiv.innerHTML = tableHTML;
        }


        /** Napi összesítő nézet generálása (Listás nézet) */
        function renderDailySummaryView() {
             console.log("Rendering Daily Summary View (List version)...");
             dailySummaryViewDiv.innerHTML = ''; // Tartalom törlése

             const today = getTodayDayName(); // Mai nap neve
             const todayDate = new Date(); // Mai dátum objektum
             const todayDateString = formatDateYYYYMMDD(todayDate); // Mai dátum YYYY-MM-DD formátumban
             const currentTimeSlotValue = getCurrentTimeSlot(timeSlots); // Aktuális idősáv értéke
             const nextTimeSlotValue = !currentTimeSlotValue ? getNextTimeSlot(timeSlots) : null; // Következő idősáv értéke
             const todayCancellations = cancellations.filter(c => c.date === todayDateString); // Mai lemondások

             // Map a mai foglalások tárolására (kulcs: room.id-slot.value)
             const todayBookingsMap = new Map();
             const sortedTimeSlots = [...timeSlots].sort((a, b) => (a.order ?? 0) - (b.order ?? 0)); // Idősávok sorrendben
             const sortedRooms = [...rooms].sort((a, b) => a.name.localeCompare(b.name)); // Termek név szerint sorrendben

             // Összegyűjtjük a mai napra vonatkozó foglalásokat és lemondásokat
             sortedRooms.forEach(room => {
                 sortedTimeSlots.forEach(slot => {
                     // Megkeressük az egyszeri foglalást
                     let booking = bookings.find(b => b.roomId === room.id && b.date === todayDateString && b.timeSlot === slot.value && b.type === 'single');
                     let isCancelled = false; // Jelzi, ha le van mondva

                     // Ha nincs egyszeri foglalás, ellenőrizzük a rendszeres foglalásokat
                     if (!booking) {
                         const recurringBooking = bookings.find(b => b.roomId === room.id && b.day === today && b.timeSlot === slot.value && b.type === 'recurring');
                         if (recurringBooking) {
                             // Ellenőrizzük, hogy az adott napra le van-e mondva ez a rendszeres foglalás
                             isCancelled = todayCancellations.some(c => c.recurringBookingId === recurringBooking.id);
                             // Ha nincs lemondva, használjuk a rendszeres sablont
                             if (!isCancelled) {
                                 booking = recurringBooking;
                             }
                         }
                     }
                     // Ha van foglalás VAGY lemondás, tároljuk a map-ben
                     if (booking || isCancelled) {
                         todayBookingsMap.set(`${room.id}-${slot.value}`, { booking: booking, isCancelled: isCancelled });
                     }
                 });
             });

            // Napi összesítő HTML generálása
            let summaryHTML = `
                <div class="sticky top-0 bg-gray-100 pt-4 pb-2 px-4 z-10 border-b mb-4">
                     <div class="flex justify-between items-center mb-2">
                        <span class="text-lg font-semibold text-gray-700">${formatFullDate(todayDate)}</span>
                        <span id="current-time-display" class="text-lg font-semibold text-gray-700">${formatTime(new Date())}</span>
                    </div>
                    <h2 class="text-2xl font-bold text-center text-indigo-700 mb-2">Terembeosztás</h2>
                </div>
            `;

            // Ellenőrizzük, van-e megjelenítendő adat
            const hasAnyData = sortedRooms.some(room =>
                 sortedTimeSlots.some(slot =>
                    todayBookingsMap.has(`${room.id}-${slot.value}`) ||
                    slot.value === currentTimeSlotValue || // Aktuális idősáv mindig megjelenik, ha van
                    slot.value === nextTimeSlotValue // Következő idősáv mindig megjelenik, ha van
                 )
            );


            if (sortedRooms.length === 0 || sortedTimeSlots.length === 0) {
                summaryHTML += `<p class="text-center text-gray-500 mt-8 px-4">Nincsenek termek vagy idősávok definiálva.</p>`;
            } else if (!hasAnyData) {
                 summaryHTML += `<p class="text-center text-gray-500 mt-8 px-4">Ma nincs tanítás vagy foglalás.</p>`;
            }
            else {
                summaryHTML += `<div class="space-y-4 px-4 daily-summary-list">`;
                sortedRooms.forEach(room => {
                    // Ellenőrizzük, hogy az adott teremnek van-e megjelenítendő adata (foglalás, lemondás, aktuális/következő idősáv)
                    const roomHasData = sortedTimeSlots.some(slot =>
                        todayBookingsMap.has(`${room.id}-${slot.value}`) ||
                        slot.value === currentTimeSlotValue ||
                        slot.value === nextTimeSlotValue
                    );

                    if (roomHasData) {
                        summaryHTML += `
                            <div class="bg-white p-4 rounded-lg shadow">
                                <h3 class="text-lg font-semibold mb-2 text-indigo-700">${escapeHtml(room.name)}</h3>
                                <ul class="divide-y divide-gray-200">`;

                        sortedTimeSlots.forEach((slot) => {
                            const bookingData = todayBookingsMap.get(`${room.id}-${slot.value}`);
                            const booking = bookingData?.booking;
                            const isCancelled = bookingData?.isCancelled ?? false;
                            const isActive = slot.value === currentTimeSlotValue;
                            const isNext = slot.value === nextTimeSlotValue;

                            // Csak akkor jelenítsük meg a slotot, ha van rá foglalás/lemondás, vagy ez az aktuális/következő idősáv
                            if (!(booking || isCancelled || isActive || isNext)) {
                                return; // Kihagyjuk ezt a slotot
                            }

                            const isBooked = !!booking;
                            const displayUser = isBooked ? escapeHtml(booking.user) : (isCancelled ? 'LEMONDVA' : 'SZABAD');
                            const displayComment = isBooked ? escapeHtml(booking.comment || '') : '';

                            // Osztályok összeállítása a timeslot-box-hoz
                            let liClasses = `timeslot-box py-2 flex justify-between items-center`;
                            if (isActive) {
                                liClasses += ' active bg-indigo-50 font-semibold';
                            } else if (isNext) {
                                liClasses += ' next-up bg-sky-50';
                            }
                             if (isCancelled) {
                                liClasses += ' opacity-60';
                            }


                            summaryHTML += `
                                <li class="${liClasses}" data-timeslot="${escapeHtml(slot.value)}">
                                    <div class="flex-grow">
                                        <span class="font-medium text-gray-800">${escapeHtml(slot.value)}</span>
                                        <span class="ml-2 ${isBooked ? 'text-gray-600' : 'text-green-600'} ${isCancelled ? '!text-gray-400 italic' : ''}"> - ${displayUser}</span>
                                        ${displayComment ? `<span class="ml-2 text-gray-500 italic">(${displayComment})</span>` : ''}
                                        ${isBooked ? `<span class="booking-type-badge">${booking.type === 'recurring' ? 'Rendszeres' : 'Egyszeri'}</span>` : ''}
                                    </div>
                                    ${isActive ? `<span class="status-indicator active !relative !top-auto !right-auto !transform-none ml-2">MOST</span>` : ''}
                                    ${isNext && !isActive ? `<span class="status-indicator next !relative !top-auto !right-auto !transform-none ml-2">KÖVETKEZIK</span>` : ''}
                                </li>
                            `;
                        });
                        summaryHTML += `</ul></div>`;
                    }
                });
                summaryHTML += `</div>`;
            }
            dailySummaryViewDiv.innerHTML = summaryHTML;
        }

        /** Adott szoba napi nézetének generálása (Átalakított stílus) */
        function renderRoomView() {
            if (!currentRoomId) return showError("Nincs kiválasztott szoba ID.");
            const room = rooms.find(r => r.id === currentRoomId);
            if (!room) return showError(`A(z) ${currentRoomId} ID-jű szoba nem található.`);

            console.log(`Rendering Room View for: ${room.name}`);
            roomViewDiv.innerHTML = ''; // Tartalom törlése

            const today = getTodayDayName(); // Mai nap neve
            const todayDate = new Date(); // Mai dátum objektum
            const todayDateString = formatDateYYYYMMDD(todayDate); // Mai dátum YYYY-MM-DD formátumban
            const sortedTimeSlots = [...timeSlots].sort((a, b) => (a.order ?? 0) - (b.order ?? 0)); // Idősávok sorrendben
            const currentTimeSlotValue = getCurrentTimeSlot(timeSlots); // Aktuális idősáv értéke
            const nextTimeSlotValue = !currentTimeSlotValue ? getNextTimeSlot(timeSlots) : null; // Következő idősáv értéke
            const todayCancellations = cancellations.filter(c => c.date === todayDateString); // Mai lemondások

            // Map a mai foglalások tárolására az adott teremben (kulcs: slot.value)
            const roomBookingsTodayMap = new Map();
            sortedTimeSlots.forEach(slot => {
                // Megkeressük az egyszeri foglalást az adott teremben, erre a napra és idősávra
                let booking = bookings.find(b => b.roomId === room.id && b.date === todayDateString && b.timeSlot === slot.value && b.type === 'single');
                let isCancelled = false; // Jelzi, ha le van mondva

                // Ha nincs egyszeri foglalás, ellenőrizzük a rendszeres foglalásokat
                if (!booking) {
                    const recurringBooking = bookings.find(b => b.roomId === room.id && b.day === today && b.timeSlot === slot.value && b.type === 'recurring');
                    if (recurringBooking) {
                        // Ellenőrizzük, hogy az adott napra le van-e mondva ez a rendszeres foglalás
                        isCancelled = todayCancellations.some(c => c.recurringBookingId === recurringBooking.id);
                        // Ha nincs lemondva, használjuk a rendszeres sablont
                        if (!isCancelled) {
                            booking = recurringBooking;
                        }
                    }
                }
                 // Ha van foglalás VAGY lemondás, tároljuk a map-ben
                 if (booking || isCancelled) {
                    roomBookingsTodayMap.set(slot.value, { booking: booking, isCancelled: isCancelled });
                 }
            });

            // Terem nézet HTML generálása
            let roomHTML = `
                 <div class="sticky top-0 bg-gray-100 pt-4 pb-2 px-4 z-10 border-b mb-4">
                     <div class="flex justify-between items-center mb-2">
                        <span class="text-lg font-semibold text-gray-700">${formatFullDate(todayDate)}</span>
                        <span id="current-time-display-room" class="text-lg font-semibold text-gray-700">${formatTime(new Date())}</span>
                    </div>
                    <h2 class="text-3xl md:text-4xl font-bold text-center text-indigo-700">${escapeHtml(room.name)}</h2>
                 </div>
            `;

            // Ellenőrizzük, van-e megjelenítendő adat ebben a teremben ma
             const hasAnyData = sortedTimeSlots.some(slot =>
                roomBookingsTodayMap.has(slot.value) ||
                slot.value === currentTimeSlotValue ||
                slot.value === nextTimeSlotValue
             );


            if (sortedTimeSlots.length === 0) {
                 roomHTML += `<p class="text-center text-gray-500 mt-10 text-lg px-4">Nincsenek elérhető idősávok definiálva ehhez a teremhez.</p>`;
            } else if (!hasAnyData) {
                 roomHTML += `<p class="text-center text-gray-500 mt-10 text-lg px-4">Ma nincs tanítás vagy foglalás ebben a teremben.</p>`;
            }
            else {
                // Szélesebb konténer a kártyáknak
                roomHTML += `<div class="max-w-2xl mx-auto px-1 sm:px-2"><ul class="space-y-2 room-view-card-list">`;
                sortedTimeSlots.forEach((slot) => {
                     const bookingData = roomBookingsTodayMap.get(slot.value);
                     const booking = bookingData?.booking;
                     const isCancelled = bookingData?.isCancelled ?? false;
                     const isActive = slot.value === currentTimeSlotValue;
                     const isNext = slot.value === nextTimeSlotValue;

                     // Csak akkor jelenítsük meg a slotot, ha van rá foglalás/lemondás, vagy ez az aktuális/következő idősáv
                     if (!(booking || isCancelled || isActive || isNext)) {
                         return; // Kihagyjuk ezt a slotot
                     }

                     const isBooked = !!booking;
                     const typeText = isBooked ? (booking.type === 'recurring' ? 'Rendszeres' : 'Egyszeri') : '';
                     const userText = isBooked ? escapeHtml(booking.user) : (isCancelled ? 'LEMONDVA' : 'SZABAD');
                     const commentText = isBooked ? escapeHtml(booking.comment || '') : '';

                     // Osztályok összeállítása a timeslot-box-hoz
                     let liClasses = `timeslot-box border-l-4 bg-white p-4 rounded-lg shadow-md relative`; // Vékony szegély, p-4 padding
                     if (isBooked) liClasses += ' border-red-500';
                     else if (isCancelled) liClasses += ' border-gray-400';
                     else liClasses += ' border-green-500'; // Szabad

                     if (isActive) {
                         liClasses += ' active bg-indigo-100 border-indigo-700';
                         if (isBooked) liClasses = liClasses.replace('bg-indigo-100 border-indigo-700', 'bg-red-100 border-red-600'); // Aktív + Foglalt szín
                     } else if (isNext) {
                         liClasses += ' next-up bg-sky-50 border-sky-300';
                         if (isBooked) liClasses = liClasses.replace('bg-sky-50 border-sky-300', 'bg-orange-50 border-orange-300'); // Következő + Foglalt szín
                     }
                     if (isCancelled) {
                         liClasses += ' opacity-70';
                     }

                     roomHTML += `
                        <li class="${liClasses}" data-timeslot="${escapeHtml(slot.value)}">
                             <div class="flex-grow flex flex-col justify-center">
                                <div class="flex justify-between items-center mb-1 relative">
                                    <span class="font-semibold text-gray-800 text-lg">${escapeHtml(slot.value)}</span>
                                    ${isActive ? `<span class="status-indicator active">MOST</span>` : ''}
                                    ${isNext && !isActive ? `<span class="status-indicator next">KÖVETKEZIK</span>` : ''}
                                </div>
                                <div class="text-gray-700 text-base">
                                    ${userText}
                                    ${isBooked ? `<span class="booking-type-badge">${typeText}</span>` : ''}
                                </div>
                                ${commentText ? `<div class="text-gray-500 text-sm italic mt-1">${commentText}</div>` : ''}
                             </div>
                             ${!isBooked && !isCancelled && currentUser ? `
                                <button
                                     onclick="handleBookingClick('${room.id}', '${escapeJsString(room.name)}', '${today}', '${escapeJsString(slot.value)}', '${todayDateString}')"
                                     class="absolute right-3 top-1/2 transform -translate-y-1/2 px-3 py-1 bg-indigo-500 text-white text-sm rounded-md hover:bg-indigo-600 transition duration-150">
                                     Foglal
                                </button>
                             ` : ''}
                        </li>
                     `;
                });
                roomHTML += `</ul></div>`;
            }
            roomViewDiv.innerHTML = roomHTML;
        }

        /** Adminisztrációs felület generálása */
        function renderAdminView() {
            // Ellenőrizzük, hogy az admin adatok betöltődtek-e
            if (allowedUsers.length === 0 && pendingUsers.length === 0 && currentUser?.isAdmin) {
                 console.log("Admin view render skipped: Admin data not loaded yet.");
                 adminViewDiv.innerHTML = '<div class="p-4 text-center text-gray-500">Admin adatok betöltése...</div>';
                 adminViewDiv.classList.add('view-loading'); // Loading jelző hozzáadása
                 return;
            }

            if (!currentUser?.isAdmin) {
                 // Ha mégis ide jutott egy nem admin, irányítsuk át
                 navigateTo('#/');
                 return;
            }
            console.log("Rendering Admin View...");
            adminViewDiv.innerHTML = ''; // Tartalom törlése
            adminViewDiv.classList.remove('view-loading'); // Loading jelző eltávolítása

            // Következő sorrend számítása az idősávokhoz
            const nextOrder = timeSlots.length > 0 ? Math.max(0, ...timeSlots.map(ts => ts.order ?? 0)) + 1 : 0;

            let adminHTML = `
                <div class="p-4 md:p-6 bg-white rounded-lg shadow space-y-8 relative">
                     <div id="admin-action-overlay" class="hidden flex-col justify-center items-center absolute inset-0 bg-white bg-opacity-75 z-20 rounded-lg">
                         <div class="spinner"></div>
                         <span class="ml-3 text-gray-700 mt-2">Folyamatban...</span>
                     </div>
                    <h2 class="text-2xl font-bold text-center text-indigo-700">Adminisztrációs Felület</h2>
                    <section>
                        <h3 class="text-xl font-semibold mb-3 text-gray-800 border-b pb-2">Hirdetmény/Üzenet a Főoldalra</h3>
                        <textarea id="admin-announcement" class="admin-input w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" rows="3" placeholder="Írj ide egy rövid üzenetet... (üresen hagyva törlődik)">${escapeHtml(announcement)}</textarea>
                        <div class="text-right mt-2">
                             <button id="save-announcement-button" data-action="save-announcement" class="admin-action-button px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition duration-150">Üzenet Mentése</button>
                        </div>
                    </section>
                    <section>
                        <h3 class="text-xl font-semibold mb-3 text-gray-800 border-b pb-2">Termek Kezelése</h3>
                        <ul id="admin-rooms-list" class="space-y-2 mb-4 max-h-60 overflow-y-auto border rounded p-2">${rooms.length === 0 ? '<li class="text-gray-500 italic">Nincsenek termek.</li>' : [...rooms].sort((a, b) => a.name.localeCompare(b.name)).map(room => `<li data-id="${room.id}" class="flex justify-between items-center p-2 border-b last:border-b-0"><span>${escapeHtml(room.name)}</span><button data-action="delete-room" class="admin-action-button text-red-600 hover:text-red-800 text-sm font-semibold px-2 py-1 rounded hover:bg-red-50">Törlés</button></li>`).join('')}</ul>
                        <div class="flex items-end space-x-2"><div class="flex-grow"><label for="newRoomName" class="block text-sm font-medium text-gray-700 mb-1">Új terem neve:</label><input type="text" id="newRoomName" class="admin-input w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="Pl. Fizika Szertár"></div><button id="add-room-button" data-action="add-room" class="admin-action-button px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition duration-150 h-10">Hozzáad</button></div>
                    </section>
                    <section>
                         <h3 class="text-xl font-semibold mb-3 text-gray-800 border-b pb-2">Idősávok Kezelése</h3>
                         <ul id="admin-timeslots-list" class="space-y-2 mb-4 max-h-60 overflow-y-auto border rounded p-2">${timeSlots.length === 0 ? '<li class="text-gray-500 italic">Nincsenek idősávok.</li>' : [...timeSlots].sort((a, b) => (a.order ?? 0) - (b.order ?? 0)).map(slot => `<li data-id="${slot.id}" class="flex justify-between items-center p-2 border-b last:border-b-0"><span>${escapeHtml(slot.value)} (Sorrend: ${slot.order ?? 'N/A'})</span><button data-action="delete-timeslot" class="admin-action-button text-red-600 hover:text-red-800 text-sm font-semibold px-2 py-1 rounded hover:bg-red-50">Törlés</button></li>`).join('')}</ul>
                         <div class="flex items-end space-x-2"><div class="flex-grow"><label for="newTimeSlotValue" class="block text-sm font-medium text-gray-700 mb-1">Új idősáv (óó:pp - óó:pp):</label><input type="text" id="newTimeSlotValue" class="admin-input w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="Pl. 16:00 - 16:45"></div><div class="w-20"><label for="newTimeSlotOrder" class="block text-sm font-medium text-gray-700 mb-1">Sorrend:</label><input type="number" id="newTimeSlotOrder" value="${nextOrder}" class="admin-input w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="0" min="0"></div><button id="add-timeslot-button" data-action="add-timeslot" class="admin-action-button px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition duration-150 h-10">Hozzáad</button></div>
                    </section>
                    <section>
                        <h3 class="text-xl font-semibold mb-3 text-gray-800 border-b pb-2">Engedélyezett Felhasználók (Aktív)</h3>
                        <ul id="admin-users-list" class="space-y-2 mb-4 max-h-60 overflow-y-auto border rounded p-2">${allowedUsers.length === 0 ? '<li class="text-gray-500 italic">Nincsenek engedélyezett felhasználók.</li>' : allowedUsers.map(allowedUser => `<li data-id="${allowedUser.id}" data-email="${escapeHtml(allowedUser.email)}" data-isadmin="${allowedUser.isAdmin}" data-nickname="${escapeHtml(allowedUser.nickname || '')}" class="flex flex-wrap justify-between items-center p-2 border-b last:border-b-0 gap-2"><div class="flex-grow"><span class="text-sm font-medium">${escapeHtml(allowedUser.nickname || allowedUser.email || 'N/A')}</span>${allowedUser.nickname ? `<span class="text-xs text-gray-500 block">(${escapeHtml(allowedUser.email || 'N/A')})</span>` : ''}<span class="text-xs text-gray-500 block break-all">UID: ${allowedUser.id}</span></div><div class="flex space-x-2 flex-shrink-0 items-center">${allowedUser.isAdmin ? '<span class="font-bold text-purple-700 text-xs mr-2">(Admin)</span>' : ''}<button data-action="edit-user" class="admin-action-button text-xs px-2 py-1 rounded bg-gray-500 hover:bg-gray-600 text-white">Név Szerk.</button><button data-action="toggle-admin" class="admin-action-button text-xs px-2 py-1 rounded ${allowedUser.isAdmin ? 'bg-yellow-500 hover:bg-yellow-600' : 'bg-blue-500 hover:bg-blue-600'} text-white ${allowedUser.id === currentUser?.uid ? 'opacity-50 cursor-not-allowed' : ''}" ${allowedUser.id === currentUser?.uid ? 'disabled' : ''}>${allowedUser.isAdmin ? 'Admin Elvétel' : 'Admin Adás'}</button><button data-action="delete-user" class="admin-action-button text-red-600 hover:text-red-800 text-xs font-semibold px-2 py-1 rounded hover:bg-red-50 ${allowedUser.id === currentUser?.uid ? 'opacity-50 cursor-not-allowed' : ''}" ${allowedUser.id === currentUser?.uid ? 'disabled' : ''}>Eltávolít</button></div></li>`).join('')}</ul>
                    </section>
                    <section>
                        <h3 class="text-xl font-semibold mb-3 text-gray-800 border-b pb-2">Meghívott Felhasználók (Email Alapú)</h3>
                        <ul id="admin-pending-users-list" class="space-y-2 mb-4 max-h-60 overflow-y-auto border rounded p-2">
                            ${pendingUsers.length === 0 ? '<li class="text-gray-500 italic">Nincsenek meghívott felhasználók.</li>' :
                                pendingUsers.map(pending => `
                                <li data-email="${escapeHtml(pending.id)}" data-isadmin="${pending.isAdmin}" data-nickname="${escapeHtml(pending.nickname || '')}" class="flex flex-wrap justify-between items-center p-2 border-b last:border-b-0 gap-2">
                                    <div class="flex-grow">
                                        <span class="text-sm font-medium">${escapeHtml(pending.nickname || pending.id)}</span>
                                        ${pending.nickname ? `<span class="text-xs text-gray-500 block">(${escapeHtml(pending.id)})</span>` : ''}
                                    </div>
                                    <div class="flex space-x-2 flex-shrink-0 items-center">
                                        ${pending.isAdmin ? '<span class="font-bold text-purple-700 text-xs mr-2">(Adminnak meghívva)</span>' : '<span class="text-xs text-gray-500 mr-2">(Felhasználónak meghívva)</span>'}
                                        <button data-action="edit-pending" class="admin-action-button text-xs px-2 py-1 rounded bg-gray-500 hover:bg-gray-600 text-white">Szerkeszt</button>
                                        <button data-action="delete-pending" class="admin-action-button text-red-600 hover:text-red-800 text-xs font-semibold px-2 py-1 rounded hover:bg-red-50">Meghívás Törlése</button>
                                    </div>
                                </li>`).join('')
                            }
                        </ul>
                        <div class="flex flex-col sm:flex-row items-end space-y-2 sm:space-y-0 sm:space-x-2 border-t pt-4">
                            <div class="flex-grow w-full sm:w-1/3">
                                <label for="newPendingUserEmail" class="block text-sm font-medium text-gray-700 mb-1">Új felhasználó Email címe:</label>
                                <input type="email" id="newPendingUserEmail" class="admin-input w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="user@example.com">
                            </div>
                             <div class="flex-grow w-full sm:w-1/3">
                                <label for="newPendingUserNickname" class="block text-sm font-medium text-gray-700 mb-1">Megj. név/Becenév (opc.):</label>
                                <input type="text" id="newPendingUserNickname" class="admin-input w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="Pl. Kovács János">
                            </div>
                            <div class="flex items-center h-10 pt-2 sm:pt-0">
                                <input type="checkbox" id="newPendingUserIsAdmin" class="admin-input mr-2 rounded border-gray-300 text-indigo-600 shadow-sm focus:ring-indigo-500">
                                <label for="newPendingUserIsAdmin" class="text-sm font-medium text-gray-700">Legyen Admin?</label>
                            </div>
                            <button id="add-pending-user-button" data-action="add-pending" class="admin-action-button px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition duration-150 h-10 w-full sm:w-auto">Meghívás</button>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">A felhasználó az első bejelentkezése után kapja meg a jogosultságot.</p>
                    </section>
                </div>
            `;
            adminViewDiv.innerHTML = adminHTML;
            // Eseményfigyelő hozzáadása a delegáláshoz (csak egyszer)
            adminViewDiv.removeEventListener('click', handleAdminActions); // Eltávolítjuk az esetleges korábbi figyelőt
            adminViewDiv.addEventListener('click', handleAdminActions);
        }

        // --- Segédfüggvények ---
        // HTML speciális karakterek escape-elése
        function escapeHtml(unsafe) { return unsafe ? unsafe.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;") : ''; }
        // JavaScript string escape-elése
        function escapeJsString(unsafe) { return unsafe ? unsafe.toString().replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/\n/g, '\\n') : '';}


        // --- Firebase Hitelesítés ---
        // Beállítja a Firebase Auth állapotfigyelőt
        function setupAuthListener() {
             console.log("setupAuthListener() called");
             if (!auth) {
                 console.error("Auth service not initialized.");
                 showError("Auth szolgáltatás nem inicializálódott.");
                 // Promise azonnali feloldása hiba esetén
                 authStatePromise = Promise.resolve();
                 return;
             }

             // Létrehozunk egy Promise-t, ami akkor oldódik fel, ha az auth state először beállt
             // Ez segít a handleRouteChange-nek megvárni a felhasználó státuszát
             authStatePromise = new Promise((resolve) => {
                 // onAuthStateChanged figyelő
                 const unsubscribe = auth.onAuthStateChanged(async (user) => {
                     console.log(">>> onAuthStateChanged triggered. User:", user ? user.uid : 'null');
                    let resolvedUser = null; // A végleges felhasználói objektum

                    if (user) { // Ha van bejelentkezett Firebase user
                        console.log("User signed in, checking authorization for UID:", user.uid);
                        const userDocRef = firestore.collection('allowedUsers').doc(user.uid);

                        try {
                            console.log("Attempting to get user document from allowedUsers...");
                            const userDoc = await userDocRef.get();

                            if (userDoc.exists) { // Ha a user már szerepel az engedélyezett listában
                                console.log("User found in allowedUsers. Data:", userDoc.data());
                                const userData = userDoc.data();
                                // Létrehozzuk a felhasználói objektumot az UID-vel és a Firestore adatokkal
                                resolvedUser = { uid: user.uid, displayName: user.displayName, email: user.email, isAdmin: userData.isAdmin || false, nickname: userData.nickname || null };

                            } else { // Ha a user nincs az engedélyezett listában, ellenőrizzük a meghívottakat (pendingUsers)
                                console.log("User not in allowedUsers, checking pendingUsers for email:", user.email ? user.email.toLowerCase() : 'N/A');
                                if (!user.email) {
                                     console.warn("User has no email, cannot check pendingUsers.");
                                     showCustomAlert(`Hozzáférés megtagadva (nincs email cím).`, "Hiba");
                                     await auth.signOut().catch(e => console.error("Sign out failed after no email:", e));
                                     resolvedUser = null;
                                } else {
                                    const pendingUserDocRef = firestore.collection('pendingUsers').doc(user.email.toLowerCase());
                                    const pendingDoc = await pendingUserDocRef.get();

                                    if (pendingDoc.exists) { // Ha a user email címe szerepel a meghívottak között
                                        console.log("User found in pendingUsers. Data:", pendingDoc.data());
                                        const pendingData = pendingDoc.data();
                                        // Létrehozzuk a felhasználói objektumot a meghívott adatokkal
                                        resolvedUser = { uid: user.uid, displayName: user.displayName, email: user.email, isAdmin: pendingData.isAdmin || false, nickname: pendingData.nickname || null };

                                        // Áthelyezzük a felhasználót a pendingUsers-ből allowedUsers-be egy batch művelettel
                                        const batch = firestore.batch();
                                        batch.set(userDocRef, { email: user.email.toLowerCase(), isAdmin: resolvedUser.isAdmin, nickname: resolvedUser.nickname });
                                        batch.delete(pendingUserDocRef);
                                        console.log("Attempting to commit batch: add to allowedUsers, delete from pendingUsers");
                                        await batch.commit();
                                        console.log("User successfully migrated from pending to allowed.");

                                        // --- Pending foglalások átvétele ---
                                        // Átírjuk a pending userhez tartozó foglalások userId mezőjét az új UID-re
                                        const pendingUserId = "pending:" + user.email.toLowerCase();
                                        const bookingsSnap = await firestore.collection('bookings').where('userId', '==', pendingUserId).get();
                                        if (!bookingsSnap.empty) {
                                            const batch2 = firestore.batch();
                                            bookingsSnap.forEach(doc => {
                                                batch2.update(doc.ref, { userId: user.uid });
                                            });
                                            await batch2.commit();
                                            console.log(`Migrated ${bookingsSnap.size} pending bookings for user ${user.email}`);
                                        }

                                    } else { // Ha a user se az engedélyezett, se a meghívott listában nincs
                                        console.warn("User not found in pendingUsers either. Access denied:", user.email);
                                        showCustomAlert(`Hozzáférés megtagadva ehhez az email címhez: ${user.email}. Kérj meghívót egy adminisztrátortól.`, "Hiba");
                                        // Kijelentkeztetjük a felhasználót, mivel nincs jogosultsága
                                        await auth.signOut().catch(e => console.error("Sign out failed:", e));
                                        resolvedUser = null;
                                    }
                                }
                            }
                        } catch (error) {
                            // Hiba kezelése a jogosultság ellenőrzése során
                            console.error("Error checking user authorization:", error);
                            showError("Hiba történt a felhasználói jogosultság ellenőrzésekor.");
                            // Hiba esetén is kijelentkeztetjük
                            await auth.signOut().catch(e => console.error("Sign out failed:", e));
                            resolvedUser = null;
                        }
                    } else {
                        // Nincs bejelentkezett Firebase user
                        console.log("User signed out.");
                        resolvedUser = null;
                    }

                    // Frissítjük a UI-t a meghatározott felhasználói állapottal
                    updateUIBasedOnAuthState(resolvedUser);
                    // Feloldjuk a Promise-t, jelezve, hogy az auth state beállt
                    resolve();
                 }, (error) => {
                     // Hiba kezelése az onAuthStateChanged figyelőben
                     console.error("Error in onAuthStateChanged listener:", error);
                     showError("Hiba történt a bejelentkezési állapot figyelésekor.");
                     // Hiba esetén is frissítjük a UI-t (kijelentkezett állapotra)
                     updateUIBasedOnAuthState(null);
                     // Feloldjuk a Promise-t hiba esetén is
                     resolve();
                });

                // A figyelőt nem kell itt leállítani, futnia kell az alkalmazás teljes életciklusa alatt
                // Az `unsubscribe` változóval később le lehetne állítani, ha szükséges lenne
             });
        }

        // Google bejelentkezés indítása
        function handleGoogleLogin() {
            if (!auth || !googleProvider) {
                console.error("Auth service or Google provider not initialized.");
                showError("Bejelentkezési szolgáltatás nem elérhető.");
                return;
            }
            // Gomb letiltása és spinner megjelenítése bejelentkezés közben
            googleLoginButton.disabled = true;
            loginSpinner.classList.remove('hidden');
            loginButtonText.textContent = 'Bejelentkezés...';

            // Google bejelentkezési popup indítása
            auth.signInWithPopup(googleProvider)
                .catch((error) => {
                    console.error("Google Sign-In Error:", error);
                     // Csak akkor mutassunk hibát, ha nem a felhasználó zárta be a popupot
                     if (error.code !== 'auth/popup-closed-by-user' && error.code !== 'auth/cancelled-popup-request') {
                        showCustomAlert(`Hiba a Google bejelentkezés során: ${error.message}`, "Hiba");
                    }
                })
                .finally(() => {
                     // Gomb visszaállítása és spinner elrejtése, ha a popup még látható
                     if (loginPopup && !loginPopup.classList.contains('hidden')) {
                         googleLoginButton.disabled = false;
                         loginSpinner.classList.add('hidden');
                         loginButtonText.textContent = 'Bejelentkezés iskolai Google-fiókkal';
                     }
                });
        }

        // Kijelentkezés kezelése
        function handleLogout() {
              if (!auth) return; // Ha nincs auth szolgáltatás, ne csináljunk semmit
             console.log("Logging out...");
             auth.signOut().catch((error) => {
                console.error("Logout failed:", error);
                showCustomAlert("Hiba történt a kijelentkezés során.", "Hiba");
             });
        }


        // --- Firestore Listenerek ---
        // Beállítja a publikus adatok (termek, idősávok, foglalások, lemondások, hirdetmény) figyelőit
        function setupPublicFirestoreListeners() {
             if (!firestore) { console.log("Skipping public Firestore listeners: no firestore."); return; }
             if (unsubscribePublicListeners.length > 0) { console.log("Public listeners already running."); return; }

            console.log("Setting up PUBLIC Firestore listeners...");
            unsubscribePublicListeners = []; // Üresítjük a listát
            initialPublicDataLoaded = false; // Kezdeti betöltés állapota
            let listenersPending = 5; // Várható listenerek száma (rooms, timeSlots, bookings, announcement, cancellations)

            // Segédfüggvény a kezdeti betöltés befejezésének ellenőrzésére
            function checkInitialLoadComplete() {
                listenersPending--;
                console.log(`Listener responded. Pending: ${listenersPending}`);
                // Ha minden listener válaszolt ÉS még nem jelöltük be a kezdeti betöltést
                if (listenersPending <= 0 && !initialPublicDataLoaded) {
                    console.log("All initial PUBLIC Firestore data loaded or errored.");
                    initialPublicDataLoaded = true; // Jelöljük, hogy a kezdeti adatok betöltődtek
                    loadingView.classList.add('hidden'); // Loading nézet elrejtése
                    handleRouteChange(); // Kezdeményezzük a routingot (most már van adat és auth state)
                } else if (initialPublicDataLoaded) {
                    // Ha már betöltődtek az adatok, de egy listener frissült, rendereljük az aktuális nézetet
                    renderView();
                }
            }

            try {
                // Termek figyelő
                const roomsRef = firestore.collection('rooms').orderBy('name');
                const unsubRooms = roomsRef.onSnapshot((snapshot) => { rooms = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); console.log("Public Rooms updated:", rooms.length); checkInitialLoadComplete(); }, (error) => { console.error("Error fetching public rooms:", error); showError("Hiba a termek betöltésekor."); checkInitialLoadComplete(); });
                unsubscribePublicListeners.push(unsubRooms); // Hozzáadjuk a listához

                // Idősávok figyelő
                const timeSlotsRef = firestore.collection('timeSlots').orderBy('order', 'asc');
                 const unsubTimeSlots = timeSlotsRef.onSnapshot((snapshot) => { timeSlots = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); console.log("Public Time slots updated:", timeSlots.length); checkInitialLoadComplete(); }, (error) => { console.error("Error fetching public time slots:", error); showError("Hiba az idősávok betöltésekor."); checkInitialLoadComplete(); });
                unsubscribePublicListeners.push(unsubTimeSlots); // Hozzáadjuk a listához

                // Foglalások figyelő
                const bookingsRef = firestore.collection('bookings');
                 const unsubBookings = bookingsRef.onSnapshot((snapshot) => { bookings = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); console.log("Public Bookings updated:", bookings.length); checkInitialLoadComplete(); }, (error) => { console.error("Error fetching public bookings:", error); showError("Hiba a foglalások betöltésekor."); checkInitialLoadComplete(); });
                unsubscribePublicListeners.push(unsubBookings); // Hozzáadjuk a listához

                 // Lemondások figyelő
                 const cancellationsRef = firestore.collection('cancellations');
                 const unsubCancellations = cancellationsRef.onSnapshot((snapshot) => { cancellations = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); console.log("Public Cancellations updated:", cancellations.length); checkInitialLoadComplete(); }, (error) => { console.error("Error fetching cancellations:", error); checkInitialLoadComplete(); });
                 unsubscribePublicListeners.push(unsubCancellations); // Hozzáadjuk a listához

                 // Hirdetmény figyelő
                 const announcementRef = firestore.collection('config').doc('announcement');
                 const unsubAnnouncement = announcementRef.onSnapshot((doc) => { announcement = doc.exists ? (doc.data().message || "") : ""; console.log("Announcement updated:", announcement); checkInitialLoadComplete(); if (initialPublicDataLoaded) displayAnnouncement(); }, (error) => { console.error("Error fetching announcement:", error); announcement = ""; checkInitialLoadComplete(); if (initialPublicDataLoaded) displayAnnouncement(); });
                 unsubscribePublicListeners.push(unsubAnnouncement); // Hozzáadjuk a listához

            } catch (error) {
                 // Hiba kezelése a figyelők beállításakor
                 console.error("Error setting up public Firestore listeners:", error);
                 showError("Hiba az adatbázis figyelőinek beállításakor.");
                 // Hiba esetén is jelezzük a kezdeti betöltés befejezését, hogy a routing elindulhasson
                 listenersPending = 0;
                 checkInitialLoadComplete();
            }
        }

        // Beállítja az admin adatok (engedélyezett/meghívott felhasználók) figyelőit
        function setupAdminFirestoreListeners() {
             // Csak akkor állítjuk be, ha van firestore és a felhasználó admin
             if (!firestore || !currentUser?.isAdmin) { console.log("Skipping admin Firestore listeners: no firestore or not admin."); return; }
             // Ne állítsuk be újra, ha már futnak
             if (unsubscribeAdminListeners.length > 0) { console.log("Admin listeners already running."); return; }
             console.log("Setting up ADMIN Firestore listeners...");
             // Először leállítjuk az esetleges korábbi admin figyelőket (bár a check a tetején ezt kezeli)
             unsubscribeAdminFirestoreListeners();

             try {
                 // Engedélyezett felhasználók figyelő
                 const allowedUsersRef = firestore.collection('allowedUsers').orderBy('email');
                 const unsubAllowedUsers = allowedUsersRef.onSnapshot((snapshot) => {
                     allowedUsers = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                     console.log("Allowed users updated:", allowedUsers.length);
                     // Ha az admin nézet aktív, frissítsük
                     if (initialPublicDataLoaded && currentView === 'admin') renderAdminView();
                     // Frissítsük a felhasználói státuszt is, ha a saját adataink változtak (pl. admin státusz)
                     if (currentUser) {
                         const updatedCurrentUser = allowedUsers.find(u => u.id === currentUser.uid);
                         if (updatedCurrentUser && (updatedCurrentUser.isAdmin !== currentUser.isAdmin || updatedCurrentUser.nickname !== currentUser.nickname)) {
                              console.log("Current user data updated from Firestore (allowedUsers).");
                              updateUIBasedOnAuthState({ ...currentUser, ...updatedCurrentUser }); // Frissítjük a currentUser objektumot
                         }
                     }
                 }, (error) => { console.error("Error fetching allowed users:", error); });
                 unsubscribeAdminListeners.push(unsubAllowedUsers); // Hozzáadjuk a listához

                 // Meghívott felhasználók figyelő
                 const pendingUsersRef = firestore.collection('pendingUsers');
                 const unsubPendingUsers = pendingUsersRef.onSnapshot((snapshot) => {
                     pendingUsers = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                     console.log("Pending users updated:", pendingUsers.length);
                     // Ha az admin nézet aktív, frissítsük
                     if (initialPublicDataLoaded && currentView === 'admin') renderAdminView();
                 }, (error) => { console.error("Error fetching pending users:", error); });
                 unsubscribeAdminListeners.push(unsubPendingUsers); // Hozzáadjuk a listához

             } catch (error) {
                 console.error("Error setting up admin Firestore listeners:", error);
                 // Admin figyelők beállításának hibája nem kritikus, nem dobunk általános showError-t
             }
        }

        // Leállítja az összes Firestore figyelőt
        function unsubscribeFirestoreListeners() {
            console.log(`Unsubscribing ${unsubscribePublicListeners.length} public and ${unsubscribeAdminListeners.length} admin listeners.`);
            [...unsubscribePublicListeners, ...unsubscribeAdminListeners].forEach(unsub => unsub());
            unsubscribePublicListeners = [];
            unsubscribeAdminListeners = [];
        }

        // Leállítja csak az admin Firestore figyelőket
        function unsubscribeAdminFirestoreListeners() {
            console.log(`Unsubscribing ${unsubscribeAdminListeners.length} admin listeners.`);
            unsubscribeAdminListeners.forEach(unsub => unsub());
            unsubscribeAdminListeners = [];
        }


        // --- Foglalási Modal Műveletek ---
        // Tárolja a foglalási modalhoz szükséges adatokat
        let bookingDataForModal = {};

        // Megnyitja a foglalási modalt
        function openBookingModal(roomId, roomName, day, timeSlot, dateString) {
             // Ellenőrizzük, hogy be van-e jelentkezve a felhasználó
             if (!currentUser) {
                 showLoginPopup("A foglaláshoz be kell jelentkezni.");
                 return;
            }

            // Tároljuk a foglalás alapadatait
            bookingDataForModal = { roomId, day, timeSlot, date: dateString };

            // Modal elemek feltöltése
            modalRoomName.textContent = roomName;
            modalDay.textContent = day;
            // Dátum objektum létrehozása a YYYY-MM-DD stringből a formázáshoz
            modalDate.textContent = formatShortDate(new Date(dateString + 'T00:00:00'));
            modalTimeslot.textContent = timeSlot;
            // Alapértelmezett foglaló név: jelenlegi felhasználó neve vagy emailje
            modalBookingUserInput.value = currentUser.nickname || currentUser.displayName || currentUser.email || '';
            modalBookingCommentInput.value = ''; // Megjegyzés mező ürítése
            modalIsRecurringCheckbox.checked = false; // Rendszeres foglalás checkbox kikapcsolása

            // Rendszeres foglalás opció csak adminoknak látható
            modalRecurringOptionDiv.classList.toggle('hidden', !currentUser.isAdmin);

            // Felhasználó választó (csak adminoknak)
            if (currentUser.isAdmin) {
                modalUserSelectorDiv.classList.remove('hidden');
                modalUserSelector.innerHTML = ''; // Üresítjük a select boxot

                // Hozzáadjuk a jelenlegi admin felhasználót a listához
                const adminOption = document.createElement('option');
                adminOption.value = currentUser.uid;
                adminOption.textContent = `${currentUser.nickname || currentUser.displayName || currentUser.email} (Én)`;
                adminOption.selected = true; // Alapértelmezettként kiválasztva
                modalUserSelector.appendChild(adminOption);

                // Hozzáadjuk az engedélyezett felhasználókat (az admin kivételével)
                allowedUsers.filter(u => u.email && u.id !== currentUser.uid).sort((a,b) => (a.nickname || a.email).localeCompare(b.nickname || b.email)).forEach(user => {
                    const option = document.createElement('option');
                    option.value = user.id;
                    option.textContent = user.nickname || user.email;
                    modalUserSelector.appendChild(option);
                });

                // Hozzáadjuk a meghívott (pending) felhasználókat
                pendingUsers.filter(u => u.id).sort((a,b) => (a.nickname || a.id).localeCompare(b.nickname || b.id)).forEach(user => {
                    const option = document.createElement('option');
                    // Pending user ID formátuma: "pending:email"
                    option.value = `pending:${user.id}`;
                    option.textContent = (user.nickname || user.id) + " (meghívott)";
                    modalUserSelector.appendChild(option);
                });

                // Eseményfigyelő a select boxhoz: ha megváltozik a kiválasztott felhasználó, frissítjük a "Foglaló neve" mezőt
                modalUserSelector.onchange = () => {
                    const selectedOption = modalUserSelector.options[modalUserSelector.selectedIndex];
                    let selectedUser = null;
                    if (selectedOption.value.startsWith('pending:')) {
                        const pendingEmail = selectedOption.value.substring(8);
                        selectedUser = pendingUsers.find(u => u.id === pendingEmail);
                        modalBookingUserInput.value = selectedUser?.nickname || selectedUser?.id || '';
                    } else {
                        selectedUser = allowedUsers.find(u => u.id === selectedOption.value);
                        modalBookingUserInput.value = selectedUser?.nickname || selectedUser?.displayName || selectedUser?.email || '';
                    }
                     console.log("User selector changed. Selected user:", selectedUser);
                };
            } else {
                // Nem admin felhasználók esetén elrejtjük a felhasználó választót
                modalUserSelectorDiv.classList.add('hidden');
            }


            // Modal megjelenítése animációval
            bookingModalElement.classList.add('active');
            requestAnimationFrame(() => { bookingModalElement.querySelector('.modal-content').classList.add('modal-enter-active'); });
        }

        // Bezárja a foglalási modalt
        function closeBookingModal() {
             const content = bookingModalElement.querySelector('.modal-content');
             content.classList.remove('modal-enter-active');
             content.classList.add('modal-leave-active'); // Animáció indítása
             // Animáció befejezése után elrejtjük a modalt
             setTimeout(() => {
                bookingModalElement.classList.remove('active');
                content.classList.remove('modal-leave-active');
             }, 300); // Animáció időtartama
        }

        // Foglalás megerősítése és mentése a Firestore-ba
        async function confirmBooking() {
            // Ellenőrizzük, hogy be van-e jelentkezve a felhasználó
            if (!currentUser) {
                showLoginPopup("A foglaláshoz be kell jelentkezni.");
                return;
            }
            // Spinner megjelenítése és gombok letiltása
            setModalLoading(true);

            // Adatok összegyűjtése a modalból
            const bookingUser = modalBookingUserInput.value.trim();
            const bookingComment = modalBookingCommentInput.value.trim();
            const isRecurring = modalIsRecurringCheckbox.checked;

            // Ellenőrizzük a kötelező mezőket
            if (!bookingUser) {
                showCustomAlert("Add meg a foglaló nevét vagy a foglalás célját!", "Hiányzó adat");
                setModalLoading(false);
                return;
            }

            // Meghatározzuk, ki a foglalás tulajdonosa (userId és user mező)
            let targetUserId = currentUser.uid;
            let targetUserName = bookingUser; // Alapértelmezett: a beírt név

            if (currentUser.isAdmin) {
                const selectedUserId = modalUserSelector.value;
                 if (selectedUserId.startsWith('pending:')) {
                    // Admin foglal egy meghívott felhasználónak
                    targetUserId = selectedUserId; // pending:email formátum
                    // A név lehet a beírt, vagy a pending user nickname/emailje, ha üres a beírt
                    const pendingEmail = selectedUserId.substring(8);
                    const pendingUser = pendingUsers.find(u => u.id === pendingEmail);
                    targetUserName = bookingUser || pendingUser?.nickname || pendingUser?.id || '';
                 } else {
                    // Admin foglal egy engedélyezett felhasználónak (beleértve saját magát is)
                    targetUserId = selectedUserId; // UID formátum
                    // A név lehet a beírt, vagy az allowed user neve, ha üres a beírt
                    const allowedUser = allowedUsers.find(u => u.id === targetUserId);
                    targetUserName = bookingUser || allowedUser?.nickname || allowedUser?.displayName || allowedUser?.email || '';
                 }
            } else {
                 // Nem admin felhasználó csak saját magának foglalhat
                 targetUserId = currentUser.uid;
                 // A név lehet a beírt, vagy a saját neve, ha üres a beírt
                 targetUserName = bookingUser || currentUser.nickname || currentUser.displayName || currentUser.email || '';
            }

            // Adatok összeállítása a mentéshez
            const dataToSave = {
                roomId: bookingDataForModal.roomId,
                day: bookingDataForModal.day, // Nap neve (Hétfő, Kedd, ...)
                timeSlot: bookingDataForModal.timeSlot, // Idősáv értéke (pl. 08:00 - 08:45)
                // Dátum csak egyszeri foglalás esetén, rendszeresnél null
                date: isRecurring ? null : bookingDataForModal.date, // YYYY-MM-DD formátum vagy null
                userId: targetUserId, // Foglaló felhasználó ID-je (UID vagy pending:email)
                user: targetUserName, // Foglaló neve / Foglalás célja (szabad szöveg)
                comment: bookingComment || null, // Megjegyzés (opcionális)
                type: isRecurring ? 'recurring' : 'single', // Típus (recurring vagy single)
                createdAt: firebase.firestore.FieldValue.serverTimestamp() // Létrehozás időpontja
            };

            console.log("Attempting to save booking with data:", dataToSave);

            try {
                // Firestore tranzakció használata a race condition elkerülésére
                // Ellenőrizzük, hogy az adott időpont nincs-e már foglalt
                await firestore.runTransaction(async (transaction) => {
                    let query = firestore.collection('bookings')
                        .where('roomId', '==', dataToSave.roomId)
                        .where('timeSlot', '==', dataToSave.timeSlot);

                    // Szűrés dátumra (egyszeri) vagy napra (rendszeres)
                    if (dataToSave.date) {
                        query = query.where('date', '==', dataToSave.date);
                    } else if (dataToSave.day) {
                        query = query.where('day', '==', dataToSave.day);
                    }

                    const snap = await transaction.get(query);

                    // Ellenőrizzük, hogy van-e már foglalás az adott időpontban
                    if (!snap.empty) {
                         // Ha van, ellenőrizzük, hogy nem lemondott rendszeres foglalásról van-e szó az aktuális napon
                         let isConflict = true;
                         if (dataToSave.type === 'single' && snap.docs.some(doc => doc.data().type === 'recurring')) {
                             // Ha egyszeri foglalást próbálunk létrehozni, de van rendszeres,
                             // ellenőrizni kell, hogy az a rendszeres foglalás nincs-e lemondva erre a napra
                             const recurringBooking = snap.docs.find(doc => doc.data().type === 'recurring');
                             if (recurringBooking) {
                                 const cancellationId = `${recurringBooking.id}_${dataToSave.date}`;
                                 const cancellationDoc = await firestore.collection('cancellations').doc(cancellationId).get();
                                 if (cancellationDoc.exists) {
                                     isConflict = false; // Nincs konfliktus, mert le van mondva a rendszeres
                                 }
                             }
                         } else {
                              // Ha van foglalás (egyszeri vagy rendszeres, ami nem lemondott eset), akkor konfliktus van
                              isConflict = snap.docs.some(doc => {
                                 const booking = doc.data();
                                 if (booking.type === 'single') return true; // Egyszeri foglalás mindig konfliktus
                                 // Rendszeres foglalás csak akkor konfliktus, ha nincs lemondva az adott napra
                                 if (booking.type === 'recurring' && dataToSave.date) {
                                     const cancellationId = `${doc.id}_${dataToSave.date}`;
                                     // Mivel tranzakcióban vagyunk, nem tudunk közvetlenül get-et hívni a 'cancellations' collection-re.
                                     // Ezt a fajta komplex ellenőrzést jobb lehet a tranzakción kívül, vagy a Firestore Security Rules-ban kezelni.
                                     // Egyszerűsítésként most feltételezzük, hogy ha van rendszeres foglalás, az konfliktus,
                                     // kivéve ha az *ugyanarra* a rendszeres foglalásra vonatkozó lemondás már létezik.
                                     // Ez a tranzakción belüli lemondás ellenőrzés sajnos bonyolult.
                                     // Egy egyszerűbb megközelítés: a tranzakció csak a foglalás létezését ellenőrzi.
                                     // A lemondás ellenőrzését a UI-ban vagy a Security Rules-ban kell jobban kezelni.
                                     // Jelenlegi tranzakció csak azt ellenőrzi, hogy van-e BÁRMILYEN foglalás az adott slotban/napon/teremben.
                                     return true; // Bármilyen meglévő foglalás konfliktusnak számít a tranzakcióban
                                 }
                                 return false;
                              });
                         }

                        if (isConflict) {
                             throw new Error("Ez az időpont már foglalt!"); // Hiba dobása, ha van konfliktus
                        }
                    }

                    // Ha nincs konfliktus, hozzáadjuk a foglalást
                    const docRef = firestore.collection('bookings').doc(); // Új dokumentum referencia
                    transaction.set(docRef, dataToSave); // Foglalás mentése
                });

                // Ha a tranzakció sikeres volt
                showCustomAlert("Foglalás sikeresen mentve!");
                closeBookingModal(); // Modal bezárása
                // Az adatok automatikusan frissülnek a listenerek miatt, nem kell manuálisan újra betölteni

            } catch (err) {
                // Hiba kezelése tranzakció vagy mentés közben
                console.error("Error adding booking:", err);
                showCustomAlert(err.message || "Ismeretlen hiba foglaláskor", 'Hiba');
            } finally {
                // Spinner elrejtése és gombok visszaállítása
                setModalLoading(false);
            }
        }

        // Beállítja a modal gombok és spinner állapotát
        function setModalLoading(isLoading) {
            modalConfirmButton.disabled = isLoading;
            modalCancelButton.disabled = isLoading;
            modalSpinner.classList.toggle('hidden', !isLoading);
            modalConfirmText.textContent = isLoading ? 'Mentés...' : 'Foglalás Mentése';
        }

        // --- Foglalás Törlése / Lemondása ---
        // Töröl egy foglalást (egyszerit teljesen, rendszereset teljesen)
        async function deleteBooking(bookingId, roomName, dayDisplay, timeSlot, bookedBy, isRecurring = false) {
              // Ellenőrizzük a jogosultságot
              if (!currentUser || !firestore) { showLoginPopup("A törléshez bejelentkezés szükséges."); return; }

             const booking = bookings.find(b => b.id === bookingId);
             if (!booking) { showCustomAlert("A foglalás nem található.", "Hiba"); return; }

            // Ellenőrizzük, hogy a foglalás a jelenlegi felhasználóé-e (UID vagy pending email alapján)
            const isOwnBooking = (
                currentUser.uid === booking.userId ||
                booking.userId === `pending:${currentUser.email?.toLowerCase()}`
            );

            // Csak admin vagy a saját egyszeri foglalását törölheti
            if (!isOwnBooking && !currentUser.isAdmin) {
                showCustomAlert("Nincs jogosultságod ennek a foglalásnak a törléséhez.", "Hiba");
                return;
            }

            // Rendszeres foglalást csak admin törölhet teljesen (a "Lemond" gomb kezeli az egyszeri lemondást)
            if (!currentUser.isAdmin && booking.type === 'recurring') {
                 showCustomAlert("Rendszeres foglalást csak adminisztrátor törölhet teljesen. Az 'Egyszeri lemondás' gombbal tudod az aktuális hetet lemondani.", "Nincs jogosultság");
                 return;
            }


             // Megerősítés kérése
             const confirmationMessage = `Biztosan törölni szeretnéd ezt a foglalást?\nTerem: ${roomName}\nIdőpont: ${dayDisplay} ${timeSlot}\nFoglaló: ${bookedBy}` + (isRecurring ? "\n\nFIGYELEM: Ez egy RENDSZERES foglalás törlése, ami minden hétről eltávolítja!" : "");
             const confirmed = await showCustomConfirm(confirmationMessage, "Megerősítés");

             if (confirmed) {
                 console.log(`Deleting booking: ${bookingId} (Recurring: ${isRecurring})`);
                 try {
                     const batch = firestore.batch(); // Batch művelet több törléshez

                     // Foglalás törlése
                     batch.delete(firestore.collection('bookings').doc(bookingId));

                     // Ha rendszeres foglalás volt, töröljük a hozzá tartozó lemondásokat is
                     if (isRecurring) {
                         const cancellationsQuery = firestore.collection('cancellations').where('recurringBookingId', '==', bookingId);
                         const cancellationsSnap = await cancellationsQuery.get();
                         if (!cancellationsSnap.empty) {
                             cancellationsSnap.forEach(doc => batch.delete(doc.ref));
                             console.log(`Added ${cancellationsSnap.size} cancellations for recurring booking ${bookingId} to batch.`);
                         }
                     }

                     await batch.commit(); // Batch művelet végrehajtása
                     showCustomAlert("Foglalás sikeresen törölve.");

                 } catch (error) {
                     console.error("Error deleting booking:", error);
                     showCustomAlert(`Hiba történt a foglalás törlésekor: ${error.message}`, "Hiba");
                 }
             } else {
                 console.log("Deletion cancelled by user.");
             }
        }

        // Lemond egy rendszeres foglalás egy adott napi esetét
        async function cancelRecurringInstance(recurringBookingId, dateString, roomName, dayDisplay, timeSlot) {
            // Ellenőrizzük a jogosultságot
            if (!currentUser || !firestore) { showLoginPopup("A lemondáshoz bejelentkezés szükséges."); return; }

            const booking = bookings.find(b => b.id === recurringBookingId);
            // Ellenőrizzük, hogy létezik a rendszeres foglalás ÉS a jelenlegi felhasználóé
            const isOwnRecurring = (
                booking && booking.type === 'recurring' &&
                (booking.userId === currentUser.uid || booking.userId === `pending:${currentUser.email?.toLowerCase()}`)
            );

            if (!isOwnRecurring) {
                showCustomAlert("Csak a saját nevedre szóló rendszeres foglalást mondhatod le erre a napra.", "Nincs jogosultság");
                return;
            }

            // Megerősítés kérése
            const confirmationMessage = `Biztosan lemondod a foglalást erre a napra?\nTerem: ${roomName}\nIdőpont: ${dayDisplay} ${timeSlot}`;
            const confirmed = await showCustomConfirm(confirmationMessage, "Lemondás megerősítése");

            if (confirmed) {
                console.log(`Cancelling instance of recurring booking: ${recurringBookingId} for date: ${dateString}`);
                try {
                    // Lemondás dokumentum ID-je: rendszeres foglalás ID-je + dátum
                    const cancellationId = `${recurringBookingId}_${dateString}`;
                    const cancellationRef = firestore.collection('cancellations').doc(cancellationId);

                    // Lemondás dokumentum létrehozása/felülírása (ha már létezik, az nem gond)
                    await cancellationRef.set({
                        recurringBookingId: recurringBookingId,
                        date: dateString,
                        cancelledByUid: currentUser.uid,
                        cancelledByName: currentUser.nickname || currentUser.displayName || currentUser.email || 'Ismeretlen',
                        cancelledAt: firebase.firestore.FieldValue.serverTimestamp()
                    });

                    showCustomAlert("Foglalás erre a napra sikeresen lemondva.");
                    // Az adatok automatikusan frissülnek a listenerek miatt

                } catch (error) {
                    console.error("Error cancelling recurring instance:", error);
                    showCustomAlert(`Hiba történt a lemondáskor: ${error.message}`, "Hiba");
                }
            } else {
                console.log("Cancellation cancelled by user.");
            }
        }

        // --- Jogosultság ellenőrzés segédfüggvények ---
        // Ellenőrzi, hogy a felhasználó törölhet-e egy foglalást a heti nézetben
        // A heti nézetben az X gomb csak adminnak vagy a saját egyszeri foglalásához jelenik meg
        function canDeleteBooking(booking, isRecurringMatch) {
             // Csak akkor, ha van bejelentkezett felhasználó ÉS (admin VAGY (a foglalás létezik ÉS egyszeri ÉS a sajátja))
            return currentUser && (
                currentUser.isAdmin ||
                (
                    booking && booking.type === 'single' &&
                    (currentUser.uid === booking.userId || booking.userId === `pending:${currentUser.email?.toLowerCase()}`)
                )
            );
             // Megjegyzés: A rendszeres foglalások teljes törlését is admin jogosultsághoz kötöttük a deleteBooking függvényben,
             // így a heti nézetben lévő X gomb nem törli a rendszeres foglalásokat a nem admin felhasználóknak.
             // Ez a függvény a heti nézetben lévő X gomb megjelenését szabályozza.
        }

        // Ellenőrzi, hogy a felhasználó lemondhat-e egy rendszeres foglalás egy adott napi esetét
        function canCancelBookingInstance(booking, isRecurringMatch, isCancelled) {
            // Csak akkor, ha van bejelentkezett felhasználó ÉS a foglalás létezik ÉS rendszeres ÉS a sajátja ÉS nincs még lemondva
            return currentUser && isRecurringMatch &&
                booking &&
                booking.type === 'recurring' &&
                (booking.userId === currentUser.uid || booking.userId === `pending:${currentUser.email?.toLowerCase()}`) &&
                !isCancelled;
        }

        // Ellenőrzi, hogy a felhasználó törölhet-e egy foglalást a részletek modalból
        // A részletek modalban az X gomb adminnak vagy a saját foglalásához (egyszeri vagy rendszeres) jelenik meg
        function canDeleteDetails(booking) {
             if (!currentUser || !booking) return false;
             // Admin törölhet bármit
             if (currentUser.isAdmin) return true;
             // Nem admin csak a saját foglalását törölheti (egyszeri vagy rendszeres)
             return (
                 currentUser.uid === booking.userId ||
                 booking.userId === `pending:${currentUser.email?.toLowerCase()}`
             );
        }


        // --- Admin Műveletek ---
        // Új terem hozzáadása
        async function addRoom() {
             if (!currentUser?.isAdmin || !firestore) return showCustomAlert("Nincs jogosultságod.", "Hiba");
            const roomNameInput = document.getElementById('newRoomName');
            const roomName = roomNameInput.value.trim();
            if (!roomName) return showCustomAlert('Add meg a terem nevét!', "Hiányzó adat");
            setAdminLoading(true); // Spinner megjelenítése
            try {
                 // Ellenőrizzük, hogy létezik-e már ilyen nevű terem (kisbetűsítve, ékezet nélkül)
                 const sanitizedNewName = sanitizeName(roomName);
                 const existingRoom = rooms.find(r => sanitizeName(r.name) === sanitizedNewName);
                 if (existingRoom) {
                     showCustomAlert(`A(z) "${roomName}" nevű terem már létezik.`, "Hiba");
                 } else {
                     await firestore.collection('rooms').add({ name: roomName }); // Terem hozzáadása
                     roomNameInput.value = ''; // Mező ürítése
                     showCustomAlert('Terem sikeresen hozzáadva.');
                 }
            }
            catch (error) {
                console.error("Error adding room:", error);
                showCustomAlert(`Hiba a terem hozzáadásakor: ${error.message}`, "Hiba");
            } finally { setAdminLoading(false); } // Spinner elrejtése
        }

        // Terem törlése
        async function deleteRoom(roomId, roomName) {
              if (!currentUser?.isAdmin || !firestore) return showCustomAlert("Nincs jogosultságod.", "Hiba");
             // Megerősítés kérése
             const confirmed = await showCustomConfirm(`Biztosan törlöd: "${roomName}"?\nFIGYELEM: Ez törli a hozzá tartozó ÖSSZES foglalást is!`, "Megerősítés");
             if (!confirmed) return;

             setAdminLoading(true); // Spinner megjelenítése
             try {
                 const batch = firestore.batch(); // Batch művelet a terem és foglalásai törléséhez

                 // Terem dokumentum törlése
                 batch.delete(firestore.collection('rooms').doc(roomId));

                 // Hozzá tartozó foglalások lekérdezése és törlése
                 const bookingsSnap = await firestore.collection('bookings').where('roomId', '==', roomId).get();
                 bookingsSnap.forEach(doc => batch.delete(doc.ref));
                 console.log(`Added ${bookingsSnap.size} bookings for room ${roomId} to batch.`);

                 // Hozzá tartozó lemondások lekérdezése és törlése (rendszeres foglalásokhoz kapcsolódva)
                 // Ez kicsit bonyolultabb, mert a lemondások recurringBookingId-re hivatkoznak.
                 // Először meg kell találni az összes rendszeres foglalást ebben a teremben.
                 const recurringBookingsInRoomSnap = await firestore.collection('bookings').where('roomId', '==', roomId).where('type', '==', 'recurring').get();
                 if (!recurringBookingsInRoomSnap.empty) {
                     const recurringBookingIds = recurringBookingsInRoomSnap.docs.map(doc => doc.id);
                     // Ez a lekérdezés nem optimális, ha nagyon sok lemondás van, de Firestore-ban nincs "WHERE IN" több mint 10 elemre.
                     // Egy jobb megoldás lehetne Cloud Functions trigger a foglalás törlésére, ami törli a lemondásokat.
                     // Most egyszerűség kedvéért lekérdezzük az összes lemondást és szűrünk.
                     const allCancellationsSnap = await firestore.collection('cancellations').get();
                     allCancellationsSnap.forEach(doc => {
                         if (recurringBookingIds.includes(doc.data().recurringBookingId)) {
                             batch.delete(doc.ref);
                             console.log(`Added cancellation ${doc.id} for recurring booking ${doc.data().recurringBookingId} to batch.`);
                         }
                     });
                 }


                 await batch.commit(); // Batch művelet végrehajtása
                 showCustomAlert(`"${roomName}" terem és a hozzá tartozó adatok sikeresen törölve.`);

             } catch (error) {
                 console.error("Error deleting room:", error);
                 showCustomAlert(`Hiba a terem törlésekor: ${error.message}`, "Hiba");
             } finally { setAdminLoading(false); } // Spinner elrejtése
        }

        // Új idősáv hozzáadása
        async function addTimeSlot() {
             if (!currentUser?.isAdmin || !firestore) return showCustomAlert("Nincs jogosultságod.", "Hiba");
            const valueInput = document.getElementById('newTimeSlotValue');
            const orderInput = document.getElementById('newTimeSlotOrder');
            const value = valueInput.value.trim();
            const order = parseInt(orderInput.value, 10); // Order számmá alakítása
            // Ellenőrizzük a formátumot és az order érvényességét
            if (!value || !/^\d{2}:\d{2}\s*-\s*\d{2}:\d{2}$/.test(value)) return showCustomAlert('Hibás idősáv formátum! Használd az óó:pp - óó:pp formátumot.', "Hibás formátum");
             if (isNaN(order) || order < 0) return showCustomAlert('Hibás sorrend érték! Adj meg egy nem negatív számot.', "Hibás adat");

            setAdminLoading(true); // Spinner megjelenítése
            try {
                 // Ellenőrizzük, hogy létezik-e már pontosan ilyen idősáv
                 const existingSlot = timeSlots.find(ts => ts.value === value);
                 if (existingSlot) {
                      showCustomAlert(`A(z) "${value}" idősáv már létezik.`, "Hiba");
                 } else {
                     await firestore.collection('timeSlots').add({ value, order }); // Idősáv hozzáadása
                     valueInput.value = ''; // Mező ürítése
                     orderInput.value = timeSlots.length > 0 ? Math.max(0, ...timeSlots.map(ts => ts.order ?? 0)) + 1 : 0; // Következő sorrend beállítása
                     showCustomAlert('Idősáv sikeresen hozzáadva.');
                 }
            }
            catch (error) {
                console.error("Error adding time slot:", error);
                showCustomAlert(`Hiba az idősáv hozzáadásakor: ${error.message}`, "Hiba");
            } finally { setAdminLoading(false); } // Spinner elrejtése
        }

        // Idősáv törlése
        async function deleteTimeSlot(slotId, slotValue) {
             if (!currentUser?.isAdmin || !firestore) return showCustomAlert("Nincs jogosultságod.", "Hiba");
             // Megerősítés kérése
             const confirmed = await showCustomConfirm(`Biztosan törlöd: "${slotValue}"?\nFIGYELEM: Ez törli a hozzá tartozó ÖSSZES foglalást is!`, "Megerősítés");
            if (!confirmed) return;

            setAdminLoading(true); // Spinner megjelenítése
            try {
                 const batch = firestore.batch(); // Batch művelet

                 // Idősáv dokumentum törlése
                 batch.delete(firestore.collection('timeSlots').doc(slotId));

                 // Hozzá tartozó foglalások lekérdezése és törlése
                 const bookingsSnap = await firestore.collection('bookings').where('timeSlot', '==', slotValue).get();
                 bookingsSnap.forEach(doc => batch.delete(doc.ref));
                 console.log(`Added ${bookingsSnap.size} bookings for time slot ${slotValue} to batch.`);

                 // Hozzá tartozó lemondások lekérdezése és törlése (rendszeres foglalásokhoz kapcsolódva)
                 // Itt is meg kell találni az összes rendszeres foglalást ezzel az idősávval.
                 const recurringBookingsInSlotSnap = await firestore.collection('bookings').where('timeSlot', '==', slotValue).where('type', '==', 'recurring').get();
                  if (!recurringBookingsInSlotSnap.empty) {
                     const recurringBookingIds = recurringBookingsInSlotSnap.docs.map(doc => doc.id);
                     const allCancellationsSnap = await firestore.collection('cancellations').get();
                      allCancellationsSnap.forEach(doc => {
                         if (recurringBookingIds.includes(doc.data().recurringBookingId)) {
                             batch.delete(doc.ref);
                             console.log(`Added cancellation ${doc.id} for recurring booking ${doc.data().recurringBookingId} to batch.`);
                         }
                     });
                 }

                 await batch.commit(); // Batch művelet végrehajtása
                 showCustomAlert(`"${slotValue}" idősáv és a hozzá tartozó adatok sikeresen törölve.`);

            } catch (error) {
                console.error("Error deleting time slot:", error);
                showCustomAlert(`Hiba az idősáv törlésekor: ${error.message}`, "Hiba");
            } finally { setAdminLoading(false); } // Spinner elrejtése
        }

        // Új felhasználó meghívása (email alapú)
        async function addPendingUser() { // Email alapú meghívó
              if (!currentUser?.isAdmin || !firestore) return showCustomAlert("Nincs jogosultságod.", "Hiba");
             const emailInput = document.getElementById('newPendingUserEmail');
             const nicknameInput = document.getElementById('newPendingUserNickname');
             const isAdminCheckbox = document.getElementById('newPendingUserIsAdmin');

             const email = emailInput.value.trim().toLowerCase();
             const nickname = nicknameInput.value.trim();
             const isAdmin = isAdminCheckbox.checked;

             // Email formátum ellenőrzése
             if (!email || !email.includes('@') || email.indexOf('@') === 0 || email.indexOf('@') === email.length - 1) {
                 return showCustomAlert('Adj meg egy érvényes email címet!', "Hibás email");
             }

             setAdminLoading(true); // Spinner megjelenítése
             try {
                 const docRef = firestore.collection('pendingUsers').doc(email);
                 const docSnap = await docRef.get();

                 // Ellenőrizzük, hogy az email már szerepel-e az engedélyezett felhasználók között
                 const allowedQuery = firestore.collection('allowedUsers').where('email', '==', email);
                 const allowedSnap = await allowedQuery.get();
                 if (!allowedSnap.empty) {
                     showCustomAlert(`"${email}" már szerepel az engedélyezett felhasználók között. Nem kell meghívni.`, "Információ");
                     setAdminLoading(false);
                     return;
                 }

                 // Ha már meg van hívva, kérdezzük meg, hogy frissítse-e
                 if (docSnap.exists) {
                      const confirmed = await showCustomConfirm(`"${email}" már meg van hívva. Frissíted a jogosultságát (${docSnap.data().isAdmin ? 'Admin' : 'Felhasználó'} -> ${isAdmin ? 'Admin' : 'Felhasználó'}) és a nevét?`, "Megerősítés");
                      if (!confirmed) {
                          setAdminLoading(false);
                          return;
                      }
                 }

                 // Meghívó mentése/frissítése
                 await docRef.set({ isAdmin: isAdmin, nickname: nickname || null });
                 emailInput.value = ''; // Mezők ürítése
                 nicknameInput.value = '';
                 isAdminCheckbox.checked = false;
                 showCustomAlert(`"${email}" sikeresen meghívva.`);

             } catch (error) {
                 console.error("Error adding pending user:", error);
                 showCustomAlert(`Hiba a meghíváskor: ${error.message}`, "Hiba");
             } finally { setAdminLoading(false); } // Spinner elrejtése
        }

        // Engedélyezett felhasználó eltávolítása (UID alapú)
        async function deleteAllowedUser(userId, userEmail) { // UID alapú törlés
             if (!currentUser?.isAdmin || !firestore) return showCustomAlert("Nincs jogosultságod.", "Hiba");
            // Admin nem távolíthatja el saját magát
            if (userId === currentUser.uid) return showCustomAlert('Magadat nem távolíthatod el az engedélyezettek közül.', "Nincs jogosultság");

            // Megerősítés kérése
            const confirmed = await showCustomConfirm(`Biztosan eltávolítod az engedélyezettek közül: "${userEmail || userId}"?\nFIGYELEM: Ez nem törli a foglalásait, de többé nem tud bejelentkezni!`, "Megerősítés");
            if (!confirmed) return;

            setAdminLoading(true); // Spinner megjelenítése
            try {
                 // Felhasználó dokumentum törlése az allowedUsers kollekcióból
                 await firestore.collection('allowedUsers').doc(userId).delete();
                 showCustomAlert(`"${userEmail || userId}" sikeresen eltávolítva az engedélyezettek listájáról.`);
                 // A felhasználó ki lesz jelentkeztetve az onAuthStateChanged figyelő miatt
            }
            catch (error) {
                console.error("Error deleting allowed user:", error);
                showCustomAlert(`Hiba a felhasználó eltávolításakor: ${error.message}`, "Hiba");
            } finally { setAdminLoading(false); } // Spinner elrejtése
        }

        // Meghívott felhasználó meghívásának törlése (email alapú)
        async function deletePendingUser(email) { // Email alapú törlés
             if (!currentUser?.isAdmin || !firestore) return showCustomAlert("Nincs jogosultságod.", "Hiba");
             // Megerősítés kérése
             const confirmed = await showCustomConfirm(`Biztosan törlöd a meghívót: "${email}"?`, "Megerősítés");
            if (!confirmed) return;

            setAdminLoading(true); // Spinner megjelenítése
            try {
                 // Meghívó dokumentum törlése a pendingUsers kollekcióból
                 await firestore.collection('pendingUsers').doc(email).delete();
                 showCustomAlert(`"${email}" meghívója sikeresen törölve.`);
            }
            catch (error) {
                console.error("Error deleting pending user:", error);
                showCustomAlert(`Hiba a meghívó törlésekor: ${error.message}`, "Hiba");
            } finally { setAdminLoading(false); } // Spinner elrejtése
        }

        // Felhasználó admin státuszának váltása (UID alapú)
        async function toggleAdminStatus(userId, userEmail, currentIsAdmin) { // UID alapú
              if (!currentUser?.isAdmin || !firestore) return showCustomAlert("Nincs jogosultságod.", "Hiba");
             // Admin nem módosíthatja saját státuszát
             if (userId === currentUser.uid) return showCustomAlert('Saját admin státuszodat nem módosíthatod.', "Nincs jogosultság");

             setAdminLoading(true); // Spinner megjelenítése
             try {
                 // Felhasználó dokumentum frissítése az allowedUsers kollekcióban
                 await firestore.collection('allowedUsers').doc(userId).update({ isAdmin: !currentIsAdmin });
                 showCustomAlert(`"${userEmail || userId}" admin státusza sikeresen módosítva.`);
                 // A felhasználó UI-ja automatikusan frissül a listener miatt
             }
             catch (error) {
                 console.error("Error toggling admin status:", error);
                 showCustomAlert(`Hiba az admin státusz módosításakor: ${error.message}`, "Hiba");
             } finally { setAdminLoading(false); } // Spinner elrejtése
        }

        // Engedélyezett felhasználó nevének szerkesztése (UID alapú)
        async function editUser(userId, currentEmail, currentNickname) { // Allowed user szerkesztése
            if (!currentUser?.isAdmin || !firestore) return showCustomAlert("Nincs jogosultságod.", "Hiba");
            // Prompt ablak az új név bekérésére
            const newNickname = prompt(`Add meg "${currentEmail}" új megjelenítendő nevét (üresen hagyva törli):`, currentNickname || '');
            // Ha a felhasználó Cancel-t nyomott a promptban
            if (newNickname === null) return;

            setAdminLoading(true); // Spinner megjelenítése
            try {
                 // Felhasználó dokumentum frissítése az allowedUsers kollekcióban
                 await firestore.collection('allowedUsers').doc(userId).update({ nickname: newNickname.trim() || null });
                 showCustomAlert(`"${currentEmail}" megjelenítendő neve sikeresen frissítve.`);
                 // A felhasználó UI-ja automatikusan frissül a listener miatt
            }
            catch (error) {
                console.error("Error editing user:", error);
                showCustomAlert(`Hiba a név frissítésekor: ${error.message}`, "Hiba");
            } finally { setAdminLoading(false); } // Spinner elrejtése
        }

        // Meghívott felhasználó adatainak szerkesztése (email alapú)
        async function editPendingUser(email, currentNickname, currentIsAdmin) { // Pending user szerkesztése
            if (!currentUser?.isAdmin || !firestore) return showCustomAlert("Nincs jogosultságod.", "Hiba");

            // Prompt ablak az új név bekérésére
            const newNickname = prompt(`Add meg "${email}" új megjelenítendő nevét (üresen hagyva törli):`, currentNickname || '');
            if (newNickname === null) return; // Ha Cancel

            // Confirm ablak az admin státusz módosítására
            const confirmed = await showCustomConfirm(`Legyen "${email}" adminisztrátor? (Jelenlegi: ${currentIsAdmin ? 'Igen' : 'Nem'})`, "Jogosultság módosítása");
            const newIsAdmin = confirmed; // A confirm eredménye (true/false)

            setAdminLoading(true); // Spinner megjelenítése
            try {
                 // Meghívó dokumentum frissítése a pendingUsers kollekcióban
                 await firestore.collection('pendingUsers').doc(email).update({ nickname: newNickname.trim() || null, isAdmin: newIsAdmin });
                 showCustomAlert(`"${email}" meghívott adatai sikeresen frissítve.`);
                 // Az admin nézet automatikusan frissül a listener miatt
            }
            catch (error) {
                console.error("Error editing pending user:", error);
                showCustomAlert(`Hiba a meghívott adatainak frissítésekor: ${error.message}`, "Hiba");
            } finally { setAdminLoading(false); } // Spinner elrejtése
        }

        // Beállítja az admin felület loading állapotát (overlay és gombok/inputok letiltása)
        function setAdminLoading(isLoading) {
              const overlay = document.getElementById('admin-action-overlay');
             const inputs = adminViewDiv.querySelectorAll('.admin-input');
             const buttons = adminViewDiv.querySelectorAll('.admin-action-button');

             // Overlay megjelenítése/elrejtése
             overlay?.classList.toggle('hidden', !isLoading);
             overlay?.classList.toggle('flex', isLoading); // Flexbox a spinner centírozásához

             // Input mezők letiltása/engedélyezése
             inputs.forEach(input => input.disabled = isLoading);

             // Gombok letiltása/engedélyezése
             buttons.forEach(button => {
                 // Saját magát érintő admin műveletek gombjait nem tiltjuk le, ha az admin loading van,
                 // de a jogosultság ellenőrzés a click handlerben ezt kezeli.
                 // Itt csak az általános loading állapotot kezeljük.
                 const li = button.closest('li');
                 const userId = li?.dataset.id;
                 // Ne tiltsd le a saját user/admin gombjait, ha nem magát törli/adminozza
                 const isSelfAction = (button.dataset.action === 'delete-user' || button.dataset.action === 'toggle-admin') && userId === currentUser?.uid;

                 button.disabled = isLoading; // Minden gomb letiltása loading alatt

                 // Kivétel: Saját magát érintő gombok (törlés, admin státusz váltás)
                 // Ezeket a jogosultság ellenőrzés a handleAdminActions-ben kezeli
                 // Itt csak visszaállítjuk az állapotukat, ha nem loading van
                 if (!isLoading && isSelfAction) {
                      button.disabled = true; // Saját gombokat továbbra is letiltva tartjuk
                 }
             });
        }

        // Hirdetmény mentése
        async function saveAnnouncement() {
            if (!currentUser?.isAdmin || !firestore) return showCustomAlert("Nincs jogosultságod.", "Hiba");
            const message = document.getElementById('admin-announcement').value.trim();

            setAdminLoading(true); // Spinner megjelenítése
            try {
                // Hirdetmény mentése/frissítése a config kollekcióban
                await firestore.collection('config').doc('announcement').set({ message: message });
                showCustomAlert("Hirdetmény sikeresen mentve.");
                announcement = message; // Globális változó frissítése
                displayAnnouncement(); // Hirdetmény megjelenítésének frissítése
            } catch (error) {
                console.error("Error saving announcement:", error);
                showCustomAlert(`Hiba a hirdetmény mentésekor: ${error.message}`, "Hiba");
            }
            finally { setAdminLoading(false); } // Spinner elrejtése
        }


        // --- Eseményfigyelők ---
        // Beállítja az alapvető eseményfigyelőket (hashchange, login/logout gombok, modal bezárása)
        function setupEventListeners() {
            console.log("Setting up event listeners...");
            window.addEventListener('hashchange', handleRouteChange); // URL hash változás figyelése
            googleLoginButton.addEventListener('click', handleGoogleLogin); // Google login gomb
            loginPopupCloseButton.addEventListener('click', () => loginPopup.classList.add('hidden')); // Login popup bezárása
            modalCancelButton.addEventListener('click', closeBookingModal); // Foglalás modal Mégse gomb
            modalConfirmButton.addEventListener('click', confirmBooking); // Foglalás modal Mentés gomb
            bookingDetailsCloseButton.addEventListener('click', closeBookingDetailsModal); // Részletek modal bezárása
            console.log("Base event listeners attached.");
        }

         // --- Admin Eseménykezelő (Delegálás) ---
         // Delegált eseménykezelő az admin felület gombjaihoz
        function handleAdminActions(event) {
             // Megkeressük a legközelebbi gomb elemet, ami rendelkezik data-action attribútummal
             const button = event.target.closest('.admin-action-button');
            if (!button) return; // Ha nem gombra kattintott, kilépünk

            // Adatok kinyerése a gomb data attribútumaiból és a listaelemből
            const action = button.dataset.action; // A végrehajtandó művelet
            const li = button.closest('li'); // A gombot tartalmazó listaelem
            const id = li?.dataset.id; // UID vagy Firestore dokumentum ID
            const email = li?.dataset.email; // Email cím (pending users)
            const isadmin = li?.dataset.isadmin === 'true'; // Admin státusz (boolean)
            const nickname = li?.dataset.nickname; // Becenév
            const nameElement = li?.querySelector('span'); // A listaelem fő szövege (pl. terem neve, email)
            let name = nameElement?.textContent; // A név/érték

            console.log("Admin action:", action, "ID:", id, "Email:", email, "IsAdmin:", isadmin, "Name:", name, "Nickname:", nickname);

            // Művelet végrehajtása a data-action alapján
            if (action === 'delete-room' && id && name) deleteRoom(id, name);
            else if (action === 'delete-timeslot' && id && name) deleteTimeSlot(id, name.split(' (')[0]); // Idősáv értékének kinyerése
            else if (action === 'toggle-admin' && id) toggleAdminStatus(id, email, isadmin);
            else if (action === 'delete-user' && id) deleteAllowedUser(id, email);
            else if (action === 'delete-pending' && email) deletePendingUser(email);
            else if (action === 'edit-user' && id) editUser(id, email, nickname);
            else if (action === 'edit-pending' && email) editPendingUser(email, nickname, isadmin);
            // Gombok ID-je alapján történő műveletek
            else if (button.id === 'add-room-button') addRoom();
            else if (button.id === 'add-timeslot-button') addTimeSlot();
            else if (button.id === 'add-pending-user-button') addPendingUser();
            else if (button.id === 'save-announcement-button') saveAnnouncement();
        }

        // --- Login Popup Kezelése ---
        // Megjeleníti a bejelentkezési popupot
        function showLoginPopup(message = "Ehhez a művelethez bejelentkezés szükséges.") {
            loginPopupMessage.textContent = message; // Üzenet beállítása
            loginPopup.classList.remove('hidden'); // Popup megjelenítése
            // Gomb/spinner állapot visszaállítása, ha esetleg loading állapotban maradt
            googleLoginButton.disabled = false;
            loginSpinner.classList.add('hidden');
            loginButtonText.textContent = 'Bejelentkezés iskolai Google-fiókkal';
        }

        // --- Foglalás Kattintás Kezelése ---
        // Kezeli a foglalás gombra kattintást a heti és terem nézetben
        function handleBookingClick(roomId, roomName, day, timeSlot, dateString) {
            // Ha nincs bejelentkezve, mutassuk a login popupot
            if (!currentUser) {
                showLoginPopup("A foglaláshoz be kell jelentkezni.");
            } else {
                 // Ha be van jelentkezve, nyissuk meg a foglalási modalt
                 openBookingModal(roomId, roomName, day, timeSlot, dateString);
            }
        }

        // --- Egyedi Alert/Confirm Modal ---
        // Promise resolve függvénye a showCustomConfirm-hoz
        let confirmResolve = null;

        // Megjeleníti az egyedi dialógus ablakot (alert vagy confirm)
        function showCustomDialog(message, type = 'alert', title = 'Értesítés') {
            // Üzenet beállítása (sortörések kezelése)
            customDialogMessage.innerHTML = message.replace(/\n/g, '<br>');
            customDialogButtons.innerHTML = ''; // Gombok területének ürítése

            // Gombok hozzáadása a típus alapján
            if (type === 'confirm') {
                // Mégse gomb
                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'Mégse';
                cancelButton.className = 'px-4 py-2 bg-gray-300 text-gray-800 rounded-md hover:bg-gray-400 transition duration-150';
                // Eseményfigyelő: bezárja a dialógust és false-zal oldja fel a Promise-t
                cancelButton.onclick = () => { customDialog.classList.remove('active'); if (confirmResolve) confirmResolve(false); confirmResolve = null; };
                customDialogButtons.appendChild(cancelButton);

                // OK gomb (confirm esetén)
                const okButton = document.createElement('button');
                okButton.textContent = 'OK';
                okButton.className = 'px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition duration-150';
                 // Eseményfigyelő: bezárja a dialógust és true-val oldja fel a Promise-t
                okButton.onclick = () => { customDialog.classList.remove('active'); if (confirmResolve) confirmResolve(true); confirmResolve = null; };
                customDialogButtons.appendChild(okButton);

            } else { // Alert típus
                // OK gomb (alert esetén)
                const okButton = document.createElement('button');
                okButton.textContent = 'OK';
                okButton.className = 'px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition duration-150';
                // Eseményfigyelő: csak bezárja a dialógust
                okButton.onclick = () => customDialog.classList.remove('active');
                customDialogButtons.appendChild(okButton);
            }

            // Dialógus megjelenítése animációval
            customDialog.classList.add('active');
            requestAnimationFrame(() => { customDialog.querySelector('.modal-content').classList.add('modal-enter-active'); });
        }

        // Segédfüggvény alert megjelenítésére
        function showCustomAlert(message, title = 'Értesítés') { showCustomDialog(message, 'alert', title); }

        // Segédfüggvény confirm ablak megjelenítésére (Promise-t ad vissza)
        function showCustomConfirm(message, title = 'Megerősítés') {
            // Visszaad egy Promise-t, ami akkor oldódik fel, ha a felhasználó OK-t vagy Mégse-t nyom
            return new Promise((resolve) => {
                confirmResolve = resolve; // Mentjük a resolve függvényt a gombokhoz
                const content = customDialog.querySelector('.modal-content');

                // Ha a dialógus már nyitva van, csak frissítjük a tartalmát
                if (!customDialog.classList.contains('active')) {
                     customDialog.classList.add('active');
                     // Animáció indítása a megjelenítéskor
                     requestAnimationFrame(() => {
                         content.classList.add('modal-enter-active');
                         // Megjelenítjük a dialógust a tartalommal
                         showCustomDialog(message, 'confirm', title);
                     });
                } else {
                     // Ha már nyitva van, csak frissítjük a tartalmát
                     showCustomDialog(message, 'confirm', title);
                }
            });
        }

        // --- Foglalás Részletei Popup ---
        // Megjeleníti a foglalás részleteit egy modalban
        function showBookingDetails(bookingId, isRecurringMatch = false) { // isRecurringMatch átvétele
            // Megkeressük a foglalást az ID alapján
            const booking = bookings.find(b => b.id === bookingId);
            if (!booking) {
                 showCustomAlert("A foglalás nem található.", "Hiba");
                 return;
            }

            // Megkeressük a terem adatait
            const room = rooms.find(r => r.id === booking.roomId);

            // Megjelenítendő szövegek összeállítása
            const userDisplay = booking.user || 'Ismeretlen';
            const commentDisplay = booking.comment || 'Nincs megjegyzés';
            const typeDisplay = booking.type === 'recurring' ? 'Rendszeres' : 'Egyszeri'; // Használjuk a booking.type-ot
            // Dátum formázása (ha van dátum, különben "Minden héten")
            const dateDisplay = booking.date ? formatFullDate(new Date(booking.date + 'T00:00:00')) : 'Minden héten';
            // Nap neve (ha van nap, különben üres string)
             const dayNameDisplay = booking.day ? `${escapeHtml(booking.day)} ` : '';


            // Részletek tartalmának generálása
            bookingDetailsContent.innerHTML = `
                <p><span class="font-semibold">Terem:</span> ${escapeHtml(room?.name || booking.roomId)}</p>
                <p><span class="font-semibold">Időpont:</span> ${dayNameDisplay}${dateDisplay !== 'Minden héten' ? `(${dateDisplay})` : dateDisplay}, ${escapeHtml(booking.timeSlot)}</p>
                <p><span class="font-semibold">Foglaló/Cél:</span> ${escapeHtml(userDisplay)}</p>
                <p><span class="font-semibold">Megjegyzés:</span> ${escapeHtml(commentDisplay)}</p>
                <p><span class="font-semibold">Típus:</span> ${typeDisplay}</p>
            `;

            // Törlés gomb hozzáadása, ha a felhasználó jogosult
            bookingDetailsActions.innerHTML = ''; // Előző gombok törlése
            const canDelete = canDeleteDetails(booking); // Jogosultság ellenőrzése
            if (canDelete) {
                 const deleteButton = document.createElement('button');
                 deleteButton.textContent = 'Foglalás Törlése';
                 deleteButton.className = 'px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition duration-150';
                 // Eseményfigyelő: bezárja a részletek modalt, majd meghívja a törlés függvényt
                 deleteButton.onclick = () => {
                     closeBookingDetailsModal();
                     // A törléshez szükséges nap formátum összeállítása
                     const dayForDelete = booking.date ? `${booking.day} (${formatShortDate(new Date(booking.date + 'T00:00:00'))})` : booking.day;
                     deleteBooking(booking.id, room?.name || 'Ismeretlen terem', dayForDelete, booking.timeSlot, booking.user, booking.type === 'recurring'); // booking.type-ot adjuk át
                 };
                 bookingDetailsActions.appendChild(deleteButton);
            }

            // Részletek modal megjelenítése animációval
            bookingDetailsModal.classList.add('active');
            requestAnimationFrame(() => { bookingDetailsModal.querySelector('.modal-content').classList.add('modal-enter-active'); });
        }

        // Bezárja a foglalás részletei modalt
        function closeBookingDetailsModal() {
             const content = bookingDetailsModal.querySelector('.modal-content');
             content.classList.remove('modal-enter-active');
             content.classList.add('modal-leave-active'); // Animáció indítása
             // Animáció befejezése után elrejtjük a modalt
             setTimeout(() => {
                bookingDetailsModal.classList.remove('active');
                content.classList.remove('modal-leave-active');
             }, 300); // Animáció időtartama
        }


        // --- Óra és Napváltás Figyelő ---
        // Elindítja az aktuális idő kijelzésének frissítését és a napváltás figyelését
        function startClockAndDayCheck() {
            let lastKnownDate = formatDateYYYYMMDD(new Date()); // Utoljára ismert dátum

            // Óra frissítésének intervalja (minden másodpercben)
            if (clockInterval) clearInterval(clockInterval); // Ha már fut, leállítjuk
            clockInterval = setInterval(() => {
                const now = new Date();
                const timeString = formatTime(now);
                // Frissítjük az idő kijelzőket a napi és terem nézetben
                const timeDisplayDaily = document.getElementById('current-time-display');
                const timeDisplayRoom = document.getElementById('current-time-display-room');
                if (timeDisplayDaily) timeDisplayDaily.textContent = timeString;
                if (timeDisplayRoom) timeDisplayRoom.textContent = timeString;

                 // Frissítjük az "MOST" és "KÖVETKEZIK" jelzőket a napi és terem nézetben
                 if (currentView === 'daily-summary' || currentView === 'room') {
                     const currentSlotValue = getCurrentTimeSlot(timeSlots); // Aktuális idősáv
                     const nextSlotValue = !currentSlotValue ? getNextTimeSlot(timeSlots) : null; // Következő idősáv
                     // A nézet DIV eleme
                     const viewDiv = currentView === 'daily-summary' ? dailySummaryViewDiv : roomViewDiv;

                     // Végigmegyünk az összes idősáv elemen a nézetben
                     viewDiv.querySelectorAll('.timeslot-box').forEach(box => {
                         const slotValue = box.dataset.timeslot; // Az elemhez tartozó idősáv értéke
                         if (slotValue) {
                             const isActive = slotValue === currentSlotValue; // Aktuális idősáv?
                             const isNext = slotValue === nextSlotValue; // Következő idősáv?

                             // Osztályok hozzáadása/eltávolítása az állapot alapján
                             box.classList.toggle('active', isActive);
                             box.classList.toggle('next-up', isNext);

                             // Színek frissítése az állapot és a foglaltság alapján
                             const isBooked = box.classList.contains('border-red-500') || box.classList.contains('border-red-400'); // Ellenőrizzük, hogy foglalt-e a szegély színe alapján (nem ideális, de működik)
                             // Aktív slot színe
                             box.classList.toggle('bg-indigo-100', isActive && !isBooked);
                             box.classList.toggle('border-indigo-700', isActive && !isBooked);
                             box.classList.toggle('bg-red-100', isActive && isBooked);
                             box.classList.toggle('border-red-600', isActive && isBooked);
                             // Következő slot színe
                             box.classList.toggle('bg-sky-50', isNext && !isBooked && !isActive); // Ne legyen next-up, ha már active
                             box.classList.toggle('border-sky-300', isNext && !isBooked && !isActive);
                             box.classList.toggle('bg-orange-50', isNext && isBooked && !isActive);
                             box.classList.toggle('border-orange-300', isNext && isBooked && !isActive);


                             // Állapotjelző span-ek megjelenítése/elrejtése
                             const activeIndicator = box.querySelector('.status-indicator.active');
                             const nextIndicator = box.querySelector('.status-indicator.next');
                             if(activeIndicator) activeIndicator.classList.toggle('hidden', !isActive);
                             if(nextIndicator) nextIndicator.classList.toggle('hidden', !isNext || isActive); // Következő jelző ne jelenjen meg, ha már aktív
                         }
                     });
                 }

            }, 1000); // Minden 1000 ms (1 másodperc)

             // Napváltás ellenőrzésének intervalja (minden percben)
             if (dayCheckInterval) clearInterval(dayCheckInterval); // Ha már fut, leállítjuk
             dayCheckInterval = setInterval(() => {
                const currentDate = formatDateYYYYMMDD(new Date()); // Aktuális dátum
                // Ha a dátum megváltozott az utoljára ismerthez képest
                if (currentDate !== lastKnownDate) {
                    console.log("Midnight detected! Reloading data for new day.");
                    lastKnownDate = currentDate; // Frissítjük az utoljára ismert dátumot
                    currentMonday = getMonday(new Date()); // Frissítjük az aktuális hétfő dátumát
                    // Ha a publikus adatok már betöltődtek és nem loading/error nézetben vagyunk, rendereljük újra az aktuális nézetet
                    if (initialPublicDataLoaded && !['loading', 'error'].includes(currentView)) {
                        renderView(); // Újrarenderelés az új napi adatokkal
                    }
                }
            }, 60000); // Minden 60000 ms (1 perc)
        }

        // --- Admin Üzenet Megjelenítése ---
        // Megjeleníti vagy elrejti az admin hirdetmény sávot
        function displayAnnouncement() {
            // Csak bejelentkezett felhasználónak és csak akkor, ha van hirdetmény szöveg
            if (currentUser && announcement && announcement.trim() !== "") {
                announcementMessageSpan.textContent = announcement; // Üzenet beállítása
                announcementBar.classList.remove('hidden'); // Sáv megjelenítése
            } else {
                announcementMessageSpan.textContent = ""; // Üzenet törlése
                announcementBar.classList.add('hidden'); // Sáv elrejtése
            }
        }


        // --- Alkalmazás Indítása ---
        // Amikor a DOM teljesen betöltődött, elindítjuk az alkalmazást
        document.addEventListener('DOMContentLoaded', initializeApp);

    </script>

</body>
</html>
